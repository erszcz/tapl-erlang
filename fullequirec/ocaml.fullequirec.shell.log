Last login: Tue Feb 15 22:17:49 on ttys002
pdc
22:17:51 erszcz @ x6 : ~
$ pdc
22:17:51 erszcz @ x6 : ~/work/erszcz/tapl-erlang (master %)
$ cd ../tapl-ocaml/
22:18:16 erszcz @ x6 : ~/work/erszcz/tapl-ocaml (ocaml %)
$ l1
arith/
bot/


    1 (*
    2    The lexical analyzer: lexer.ml is generated automatically
equirec/
fomega/
fomsub/
fullequirec/
fullerror/
fullfomsub/
fullfsub/
fullfsubref/
fullisorec/
fullomega/
fullpoly/
fullrecon/
fullref/
fullsimple/
fullsub/
fulluntyped/
fullupdate/
joinexercise/
letexercise/
purefsub/
rcdsubbot/
recon/
reconbase/
simplebool/
tyarith/
untyped/
22:18:16 erszcz @ x6 : ~/work/erszcz/tapl-ocaml (ocaml %)
$ cd fullequirec/
22:18:20 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff lexer.mll ../fullsimple/lexer.mll
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:20:09 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff
diff --git a/fullequirec/lexer.mll b/fullequirec/lexer.mll
index b1f8409..f60d630 100644
--- a/fullequirec/lexer.mll
+++ b/fullequirec/lexer.mll
@@ -11,32 +11,32 @@ open Support.Error

 let reservedWords = [
   (* Keywords *)
+  ("type", fun i -> Parser.TYPE i);
   ("inert", fun i -> Parser.INERT i);
   ("if", fun i -> Parser.IF i);
   ("then", fun i -> Parser.THEN i);
   ("else", fun i -> Parser.ELSE i);
   ("true", fun i -> Parser.TRUE i);
   ("false", fun i -> Parser.FALSE i);
-  ("String", fun i -> Parser.USTRING i);
+  ("Bool", fun i -> Parser.BOOL i);
+  ("case", fun i -> Parser.CASE i);
+  ("of", fun i -> Parser.OF i);
   ("as", fun i -> Parser.AS i);
   ("lambda", fun i -> Parser.LAMBDA i);
+  ("let", fun i -> Parser.LET i);
+  ("in", fun i -> Parser.IN i);
+  ("fix", fun i -> Parser.FIX i);
+  ("letrec", fun i -> Parser.LETREC i);
+  ("String", fun i -> Parser.USTRING i);
+  ("unit", fun i -> Parser.UNIT i);
+  ("Unit", fun i -> Parser.UUNIT i);
   ("timesfloat", fun i -> Parser.TIMESFLOAT i);
   ("Float", fun i -> Parser.UFLOAT i);
-  ("type", fun i -> Parser.TYPE i);
   ("Rec", fun i -> Parser.REC i);
   ("succ", fun i -> Parser.SUCC i);
   ("pred", fun i -> Parser.PRED i);
   ("iszero", fun i -> Parser.ISZERO i);
-  ("Bool", fun i -> Parser.BOOL i);
   ("Nat", fun i -> Parser.NAT i);
-  ("case", fun i -> Parser.CASE i);
-  ("of", fun i -> Parser.OF i);
-  ("let", fun i -> Parser.LET i);
-  ("in", fun i -> Parser.IN i);
-  ("unit", fun i -> Parser.UNIT i);
-  ("Unit", fun i -> Parser.UUNIT i);
-  ("fix", fun i -> Parser.FIX i);
-  ("letrec", fun i -> Parser.LETREC i);

   (* Symbols *)
   ("_", fun i -> Parser.USCORE i);
22:20:12 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff --name-status
M       fullequirec/lexer.mll
22:20:15 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add lexer.mll
22:20:27 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git commit -m "fullequirec: Rearrange order for easier diffing with fullsimple"
[ocaml 715f3e9] fullequirec: Rearrange order for easier diffing with fullsimple
 1 file changed, 11 insertions(+), 11 deletions(-)
22:21:40 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ make
ocamllex lexer.mll
66 states, 658 transitions, table size 3028 bytes
ocamlc -c  core.ml
ocamlc -c  lexer.ml
ocamlc -c  main.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
22:21:46 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
mylist : NatList
10 : Nat
22:21:49 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:25:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:26:24 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:27:22 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:28:00 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:28:07 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlyacc -v parser.mly
ocamlc -c  parser.mli
ocamlc -c  parser.ml
ocamlc -c  lexer.ml
ocamlc -c  main.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
22:28:11 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
mylist : NatList
10 : Nat
22:28:13 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p
diff --git a/fullequirec/parser.mly b/fullequirec/parser.mly
index ba3b308..5b95605 100644
--- a/fullequirec/parser.mly
+++ b/fullequirec/parser.mly
@@ -22,32 +22,32 @@ open Syntax
  */

 /* Keyword tokens */
+%token <Support.Error.info> TYPE
 %token <Support.Error.info> INERT
 %token <Support.Error.info> IF
 %token <Support.Error.info> THEN
 %token <Support.Error.info> ELSE
 %token <Support.Error.info> TRUE
 %token <Support.Error.info> FALSE
-%token <Support.Error.info> USTRING
+%token <Support.Error.info> BOOL
+%token <Support.Error.info> CASE
+%token <Support.Error.info> OF
 %token <Support.Error.info> AS
 %token <Support.Error.info> LAMBDA
+%token <Support.Error.info> LET
+%token <Support.Error.info> IN
+%token <Support.Error.info> FIX
+%token <Support.Error.info> LETREC
+%token <Support.Error.info> USTRING
+%token <Support.Error.info> UNIT
+%token <Support.Error.info> UUNIT
 %token <Support.Error.info> TIMESFLOAT
 %token <Support.Error.info> UFLOAT
-%token <Support.Error.info> TYPE
 %token <Support.Error.info> REC
 %token <Support.Error.info> SUCC
 %token <Support.Error.info> PRED
 %token <Support.Error.info> ISZERO
-%token <Support.Error.info> BOOL
 %token <Support.Error.info> NAT
-%token <Support.Error.info> CASE
-%token <Support.Error.info> OF
-%token <Support.Error.info> LET
-%token <Support.Error.info> IN
-%token <Support.Error.info> UNIT
-%token <Support.Error.info> UUNIT
-%token <Support.Error.info> FIX
-%token <Support.Error.info> LETREC

 /* Identifier and constant value tokens */
 %token <string Support.Error.withinfo> UCID  /* uppercase-initial */
(1/10) Stage this hunk [y,n,q,a,d,j,J,g,/,s,e,?]? y
@@ -133,10 +133,10 @@ toplevel :
 Command :
   | Term
       { fun ctx -> (let t = $1 ctx in Eval(tmInfo t,t)),ctx }
-  | LCID Binder
-      { fun ctx -> ((Bind($1.i,$1.v,$2 ctx)), addname ctx $1.v) }
   | UCID TyBinder
       { fun ctx -> ((Bind($1.i, $1.v, $2 ctx)), addname ctx $1.v) }
+  | LCID Binder
+      { fun ctx -> ((Bind($1.i,$1.v,$2 ctx)), addname ctx $1.v) }

 /* Right-hand sides of top-level bindings */
 Binder :
(2/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -158,44 +158,34 @@ Type :
 AType :
     LPAREN Type RPAREN
            { $2 }
-  | USTRING
-      { fun ctx -> TyString }
-  | LCURLY FieldTypes RCURLY
-      { fun ctx ->
-          TyRecord($2 ctx 1) }
   | UCID
       { fun ctx ->
           if isnamebound ctx $1.v then
             TyVar(name2index $1.i ctx $1.v, ctxlength ctx)
           else
             TyId($1.v) }
-  | UFLOAT
-      { fun ctx -> TyFloat }
   | BOOL
       { fun ctx -> TyBool }
-  | NAT
-      { fun ctx -> TyNat }
   | LT FieldTypes GT
       { fun ctx ->
           TyVariant($2 ctx 1) }
+  | USTRING
+      { fun ctx -> TyString }
   | UUNIT
       { fun ctx -> TyUnit }
-
-AscribeTerm :
-    ATerm AS Type
-      { fun ctx -> TmAscribe($2, $1 ctx, $3 ctx) }
-  | ATerm
-      { $1 }
-
-PathTerm :
-    PathTerm DOT LCID
-      { fun ctx ->
-          TmProj($2, $1 ctx, $3.v) }
-  | PathTerm DOT INTV
+  | LCURLY FieldTypes RCURLY
       { fun ctx ->
-          TmProj($2, $1 ctx, string_of_int $3.v) }
-  | AscribeTerm
-      { $1 }
+          TyRecord($2 ctx 1) }
+  | UFLOAT
+      { fun ctx -> TyFloat }
+  | NAT
+      { fun ctx -> TyNat }
+
+TyBinder :
+    /* empty */
+      { fun ctx -> TyVarBind }
+  | EQ Type
+      { fun ctx -> TyAbbBind($2 ctx) }

 FieldTypes :
     /* empty */
(3/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -228,6 +218,9 @@ Term :
       { $1 }
   | IF Term THEN Term ELSE Term
       { fun ctx -> TmIf($1, $2 ctx, $4 ctx, $6 ctx) }
+  | CASE Term OF Cases
+      { fun ctx ->
+          TmCase($1, $2 ctx, $4 ctx) }
   | LAMBDA LCID COLON Type DOT Term
       { fun ctx ->
           let ctx1 = addname ctx $2.v in
(4/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -236,9 +229,6 @@ Term :
       { fun ctx ->
           let ctx1 = addname ctx "_" in
           TmAbs($1, "_", $4 ctx, $6 ctx1) }
-  | CASE Term OF Cases
-      { fun ctx ->
-          TmCase($1, $2 ctx, $4 ctx) }
   | LET LCID EQ Term IN Term
       { fun ctx -> TmLet($1, $2.v, $4 ctx, $6 (addname ctx $2.v)) }
   | LET USCORE EQ Term IN Term
(5/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -257,6 +247,9 @@ AppTerm :
           let e1 = $1 ctx in
           let e2 = $2 ctx in
           TmApp(tmInfo e1,e1,e2) }
+  | FIX PathTerm
+      { fun ctx ->
+          TmFix($1, $2 ctx) }
   | TIMESFLOAT PathTerm PathTerm
       { fun ctx -> TmTimesfloat($1, $2 ctx, $3 ctx) }
   | SUCC PathTerm
(6/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -265,9 +258,22 @@ AppTerm :
       { fun ctx -> TmPred($1, $2 ctx) }
   | ISZERO PathTerm
       { fun ctx -> TmIsZero($1, $2 ctx) }
-  | FIX PathTerm
+
+AscribeTerm :
+    ATerm AS Type
+      { fun ctx -> TmAscribe($2, $1 ctx, $3 ctx) }
+  | ATerm
+      { $1 }
+
+PathTerm :
+    PathTerm DOT LCID
       { fun ctx ->
-          TmFix($1, $2 ctx) }
+          TmProj($2, $1 ctx, $3.v) }
+  | PathTerm DOT INTV
+      { fun ctx ->
+          TmProj($2, $1 ctx, string_of_int $3.v) }
+  | AscribeTerm
+      { $1 }

 TermSeq :
     Term
(7/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -286,11 +292,16 @@ ATerm :
       { fun ctx -> TmTrue($1) }
   | FALSE
       { fun ctx -> TmFalse($1) }
+  | LT LCID EQ Term GT AS Type
+      { fun ctx ->
+          TmTag($1, $2.v, $4 ctx, $7 ctx) }
   | LCID
       { fun ctx ->
           TmVar($1.i, name2index $1.i ctx $1.v, ctxlength ctx) }
   | STRINGV
       { fun ctx -> TmString($1.i, $1.v) }
+  | UNIT
+      { fun ctx -> TmUnit($1) }
   | LCURLY Fields RCURLY
       { fun ctx ->
           TmRecord($1, $2 ctx 1) }
(8/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -302,11 +313,18 @@ ATerm :
               0 -> TmZero($1.i)
             | n -> TmSucc($1.i, f (n-1))
           in f $1.v }
-  | LT LCID EQ Term GT AS Type
+
+Cases :
+    Case
+      { fun ctx -> [$1 ctx] }
+  | Case VBAR Cases
+      { fun ctx -> ($1 ctx) :: ($3 ctx) }
+
+Case :
+    LT LCID EQ LCID GT DDARROW AppTerm
       { fun ctx ->
-          TmTag($1, $2.v, $4 ctx, $7 ctx) }
-  | UNIT
-      { fun ctx -> TmUnit($1) }
+          let ctx1 = addname ctx $4.v in
+          ($2.v, ($4.v, $7 ctx1)) }

 Fields :
     /* empty */
(9/10) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -326,23 +344,5 @@ Field :
   | Term
       { fun ctx i -> (string_of_int i, $1 ctx) }

-TyBinder :
-    /* empty */
-      { fun ctx -> TyVarBind }
-  | EQ Type
-      { fun ctx -> TyAbbBind($2 ctx) }
-
-Cases :
-    Case
-      { fun ctx -> [$1 ctx] }
-  | Case VBAR Cases
-      { fun ctx -> ($1 ctx) :: ($3 ctx) }
-
-Case :
-    LT LCID EQ LCID GT DDARROW AppTerm
-      { fun ctx ->
-          let ctx1 = addname ctx $4.v in
-          ($2.v, ($4.v, $7 ctx1)) }
-

 /*   */
(10/10) Stage this hunk [y,n,q,a,d,K,g,/,e,?]? y

22:28:23 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git commit -v --amend --date=now
[ocaml 8e82c01] fullequirec: Rearrange order for easier diffing with fullsimple
 Date: Tue Feb 15 22:28:29 2022 +0100
 2 files changed, 75 insertions(+), 75 deletions(-)
22:28:30 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
22:28:31 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff parser.mly ../fullsimple/syntax.ml
syntax.ml   syntax.mli
22:28:31 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:28:50 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:32:25 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:32:42 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:34:01 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:34:20 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  syntax.ml
File "syntax.ml", line 1:
Error: The implementation syntax.ml does not match the interface syntax.cmi:
       Type declarations do not match:
         type ty =
             TyVar of int * int
           | TyId of string
           | TyArr of ty * ty
           | TyUnit
           | TyRecord of (string * ty) list
           | TyRec of string * ty
           | TyVariant of (string * ty) list
           | TyBool
           | TyString
           | TyFloat
           | TyNat
       is not included in
         type ty =
             TyId of string
           | TyVar of int * int
           | TyRecord of (string * ty) list
           | TyArr of ty * ty
           | TyFloat
           | TyRec of string * ty
           | TyNat
           | TyVariant of (string * ty) list
           | TyString
           | TyBool
           | TyUnit
       Constructors number 1 have different names, TyVar and TyId.
       File "syntax.mli", lines 7-18, characters 0-10: Expected declaration
       File "syntax.ml", lines 8-19, characters 0-9: Actual declaration
make: *** [syntax.cmo] Error 2
22:34:22 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make clean
rm -rf lexer.ml parser.ml parser.mli *.o *.cmo *.cmi parser.output \
	   f f.exe TAGS *~ *.bak
22:34:31 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ make
ocamllex lexer.mll
66 states, 658 transitions, table size 3028 bytes
ocamlyacc -v parser.mly
ocamlc -c  support.mli
ocamlc -c  support.ml
ocamlc -c  syntax.mli
ocamlc -c  syntax.ml
File "syntax.ml", line 1:
Error: The implementation syntax.ml does not match the interface syntax.cmi:
       Type declarations do not match:
         type ty =
             TyVar of int * int
           | TyId of string
           | TyArr of ty * ty
           | TyUnit
           | TyRecord of (string * ty) list
           | TyRec of string * ty
           | TyVariant of (string * ty) list
           | TyBool
           | TyString
           | TyFloat
           | TyNat
       is not included in
         type ty =
             TyId of string
           | TyVar of int * int
           | TyRecord of (string * ty) list
           | TyArr of ty * ty
           | TyFloat
           | TyRec of string * ty
           | TyNat
           | TyVariant of (string * ty) list
           | TyString
           | TyBool
           | TyUnit
       Constructors number 1 have different names, TyVar and TyId.
       File "syntax.mli", lines 7-18, characters 0-10: Expected declaration
       File "syntax.ml", lines 8-19, characters 0-9: Actual declaration
make: *** [syntax.cmo] Error 2
22:34:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff
diff --git a/fullequirec/syntax.ml b/fullequirec/syntax.ml
index 057bec6..20f4b4a 100644
--- a/fullequirec/syntax.ml
+++ b/fullequirec/syntax.ml
@@ -6,29 +6,34 @@ open Support.Pervasive
 (* Datatypes *)

 type ty =
-    TyId of string
-  | TyVar of int * int
-  | TyRecord of (string * ty) list
+    TyVar of int * int
+  | TyId of string
   | TyArr of ty * ty
-  | TyFloat
+  | TyUnit
+  | TyRecord of (string * ty) list
   | TyRec of string * ty
-  | TyNat
   | TyVariant of (string * ty) list
-  | TyString
   | TyBool
-  | TyUnit
+  | TyString
+  | TyFloat
+  | TyNat

 type term =
     TmTrue of info
   | TmFalse of info
diff --git a/fullequirec/syntax.ml b/fullequirec/syntax.ml
index 057bec6..20f4b4a 100644
--- a/fullequirec/syntax.ml
+++ b/fullequirec/syntax.ml
@@ -6,29 +6,34 @@ open Support.Pervasive
 (* Datatypes *)

 type ty =
-    TyId of string
-  | TyVar of int * int
-  | TyRecord of (string * ty) list
+    TyVar of int * int
+  | TyId of string
   | TyArr of ty * ty
-  | TyFloat
+  | TyUnit
+  | TyRecord of (string * ty) list
   | TyRec of string * ty
-  | TyNat
   | TyVariant of (string * ty) list
-  | TyString
   | TyBool
-  | TyUnit
+  | TyString
+  | TyFloat
+  | TyNat

 type term =
     TmTrue of info
   | TmFalse of info
   | TmIf of info * term * term * term
+  | TmCase of info * term * (string * (string * term)) list
+  | TmTag of info * string * term * ty
   | TmVar of info * int * int
+  | TmAbs of info * string * ty * term
+  | TmApp of info * term * term
+  | TmLet of info * string * term * term
+  | TmFix of info * term
   | TmString of info * string
+  | TmUnit of info
   | TmAscribe of info * term * ty
   | TmRecord of info * (string * term) list
   | TmProj of info * term * string
-  | TmAbs of info * string * ty * term
-  | TmApp of info * term * term
   | TmFloat of info * float
   | TmTimesfloat of info * term * term
   | TmZero of info
@@ -36,17 +41,12 @@ type term =
   | TmPred of info * term
22:35:40 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ rm syntax.cmi ^C
22:36:11 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim syntax.cmi
r22:36:15 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ rm syntax.cmi
22:36:17 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make clean n
rm -rf lexer.ml parser.ml parser.mli *.o *.cmo *.cmi parser.output \
	   f f.exe TAGS *~ *.bak
make: *** No rule to make target `n'.  Stop.
22:36:20 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ make clean
rm -rf lexer.ml parser.ml parser.mli *.o *.cmo *.cmi parser.output \
	   f f.exe TAGS *~ *.bak
22:36:23 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ l1
Makefile
core.ml
core.mli
lexer.mll
main.ml
parser.mly
support.ml
support.mli
syntax.ml
syntax.mli
test.f
22:36:24 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ rm syntax.ml^C
22:36:32 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ cat syntax.mli
(* module Syntax: syntax trees and associated support functions *)

open Support.Pervasive
open Support.Error

(* Data type definitions *)
type ty =
    TyId of string
  | TyVar of int * int
  | TyRecord of (string * ty) list
  | TyArr of ty * ty
  | TyFloat
  | TyRec of string * ty
  | TyNat
  | TyVariant of (string * ty) list
  | TyString
  | TyBool
  | TyUnit

type term =
    TmTrue of info
  | TmFalse of info
  | TmIf of info * term * term * term
  | TmVar of info * int * int
  | TmString of info * string
  | TmAscribe of info * term * ty
  | TmRecord of info * (string * term) list
  | TmProj of info * term * string
  | TmAbs of info * string * ty * term
  | TmApp of info * term * term
  | TmFloat of info * float
  | TmTimesfloat of info * term * term
  | TmZero of info
  | TmSucc of info * term
  | TmPred of info * term
  | TmIsZero of info * term
  | TmInert of info * ty
  | TmCase of info * term * (string * (string * term)) list
  | TmTag of info * string * term * ty
  | TmLet of info * string * term * term
  | TmUnit of info
  | TmFix of info * term

type binding =
    NameBind
  | TmAbbBind of term * (ty option)
  | VarBind of ty
  | TyVarBind
  | TyAbbBind of ty

type command =
  | Eval of info * term
  | Bind of info * string * binding

(* Contexts *)
type context
val emptycontext : context
val ctxlength : context -> int
val addbinding : context -> string -> binding -> context
val addname: context -> string -> context
val index2name : info -> context -> int -> string
val getbinding : info -> context -> int -> binding
val name2index : info -> context -> string -> int
val isnamebound : context -> string -> bool
val getTypeFromContext : info -> context -> int -> ty

(* Shifting and substitution *)
val termShift: int -> term -> term
val termSubstTop: term -> term -> term
val typeShift : int -> ty -> ty
val typeSubstTop: ty -> ty -> ty
val tytermSubstTop: ty -> term -> term

(* Printing *)
val printtm: context -> term -> unit
val printtm_ATerm: bool -> context -> term -> unit
val printty : context -> ty -> unit
val prbinding : context -> binding -> unit

(* Misc *)
val tmInfo: term -> info

22:36:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ vimdiff syntax.mli ../fullsimple/syntax.mli
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:37:54 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *)
$ make
ocamllex lexer.mll
66 states, 658 transitions, table size 3028 bytes
ocamlyacc -v parser.mly
ocamlc -c  support.mli
ocamlc -c  support.ml
ocamlc -c  syntax.mli
ocamlc -c  syntax.ml
ocamlc -c  core.mli
ocamlc -c  core.ml
ocamlc -c  parser.mli
ocamlc -c  parser.ml
ocamlc -c  lexer.ml
ocamlc -c  main.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
22:37:59 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
mylist : NatList
10 : Nat
22:38:00 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p
diff --git a/fullequirec/syntax.ml b/fullequirec/syntax.ml
index 057bec6..20f4b4a 100644
--- a/fullequirec/syntax.ml
+++ b/fullequirec/syntax.ml
@@ -6,29 +6,34 @@ open Support.Pervasive
 (* Datatypes *)

 type ty =
-    TyId of string
-  | TyVar of int * int
-  | TyRecord of (string * ty) list
+    TyVar of int * int
+  | TyId of string
   | TyArr of ty * ty
-  | TyFloat
+  | TyUnit
+  | TyRecord of (string * ty) list
   | TyRec of string * ty
-  | TyNat
   | TyVariant of (string * ty) list
-  | TyString
   | TyBool
-  | TyUnit
+  | TyString
+  | TyFloat
+  | TyNat

 type term =
     TmTrue of info
   | TmFalse of info
   | TmIf of info * term * term * term
+  | TmCase of info * term * (string * (string * term)) list
+  | TmTag of info * string * term * ty
   | TmVar of info * int * int
+  | TmAbs of info * string * ty * term
+  | TmApp of info * term * term
+  | TmLet of info * string * term * term
+  | TmFix of info * term
   | TmString of info * string
+  | TmUnit of info
   | TmAscribe of info * term * ty
   | TmRecord of info * (string * term) list
   | TmProj of info * term * string
-  | TmAbs of info * string * ty * term
-  | TmApp of info * term * term
   | TmFloat of info * float
   | TmTimesfloat of info * term * term
   | TmZero of info
(1/14) Stage this hunk [y,n,q,a,d,j,J,g,/,s,e,?]? y
@@ -36,17 +41,12 @@ type term =
   | TmPred of info * term
   | TmIsZero of info * term
   | TmInert of info * ty
-  | TmCase of info * term * (string * (string * term)) list
-  | TmTag of info * string * term * ty
-  | TmLet of info * string * term * term
-  | TmUnit of info
-  | TmFix of info * term

 type binding =
     NameBind
-  | TmAbbBind of term * (ty option)
-  | VarBind of ty
   | TyVarBind
+  | VarBind of ty
+  | TmAbbBind of term * (ty option)
   | TyAbbBind of ty

 type context = (string * binding) list
(2/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -98,29 +98,36 @@ let rec name2index fi ctx x =

 let tymap onvar c tyT =
   let rec walk c tyT = match tyT with
-    TyString -> TyString
-  | TyFloat -> TyFloat
-  | TyVar(x,n) -> onvar c x n
+    TyVar(x,n) -> onvar c x n
   | TyRec(x,tyT) -> TyRec(x,walk (c+1) tyT)
   | TyId(b) as tyT -> tyT
+  | TyString -> TyString
+  | TyUnit -> TyUnit
+  | TyRecord(fieldtys) -> TyRecord(List.map (fun (li,tyTi) -> (li, walk c tyTi)) fieldtys)
+  | TyFloat -> TyFloat
   | TyBool -> TyBool
   | TyNat -> TyNat
   | TyArr(tyT1,tyT2) -> TyArr(walk c tyT1,walk c tyT2)
   | TyVariant(fieldtys) -> TyVariant(List.map (fun (li,tyTi) -> (li, walk c tyTi)) fieldtys)
-  | TyRecord(fieldtys) -> TyRecord(List.map (fun (li,tyTi) -> (li, walk c tyTi)) fieldtys)
-  | TyUnit -> TyUnit
   in walk c tyT

 let tmmap onvar ontype c t =
   let rec walk c t = match t with
     TmInert(fi,tyT) -> TmInert(fi,ontype c tyT)
+  | TmVar(fi,x,n) -> onvar fi c x n
+  | TmAbs(fi,x,tyT1,t2) -> TmAbs(fi,x,ontype c tyT1,walk (c+1) t2)
+  | TmApp(fi,t1,t2) -> TmApp(fi,walk c t1,walk c t2)
+  | TmLet(fi,x,t1,t2) -> TmLet(fi,x,walk c t1,walk (c+1) t2)
+  | TmFix(fi,t1) -> TmFix(fi,walk c t1)
   | TmTrue(fi) as t -> t
   | TmFalse(fi) as t -> t
   | TmIf(fi,t1,t2,t3) -> TmIf(fi,walk c t1,walk c t2,walk c t3)
-  | TmVar(fi,x,n) -> onvar fi c x n
   | TmString _ as t -> t
-  | TmAbs(fi,x,tyT1,t2) -> TmAbs(fi,x,ontype c tyT1,walk (c+1) t2)
-  | TmApp(fi,t1,t2) -> TmApp(fi,walk c t1,walk c t2)
+  | TmUnit(fi) as t -> t
+  | TmProj(fi,t1,l) -> TmProj(fi,walk c t1,l)
+  | TmRecord(fi,fields) -> TmRecord(fi,List.map (fun (li,ti) ->
+                                               (li,walk c ti))
+                                    fields)
   | TmAscribe(fi,t1,tyT1) -> TmAscribe(fi,walk c t1,ontype c tyT1)
   | TmFloat _ as t -> t
   | TmTimesfloat(fi,t1,t2) -> TmTimesfloat(fi, walk c t1, walk c t2)
(3/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -133,13 +140,6 @@ let tmmap onvar ontype c t =
       TmCase(fi, walk c t,
              List.map (fun (li,(xi,ti)) -> (li, (xi,walk (c+1) ti)))
                cases)
-  | TmProj(fi,t1,l) -> TmProj(fi,walk c t1,l)
-  | TmRecord(fi,fields) -> TmRecord(fi,List.map (fun (li,ti) ->
-                                               (li,walk c ti))
-                                    fields)
-  | TmLet(fi,x,t1,t2) -> TmLet(fi,x,walk c t1,walk (c+1) t2)
-  | TmUnit(fi) as t -> t
-  | TmFix(fi,t1) -> TmFix(fi,walk c t1)
   in walk c t

 let typeShiftAbove d c tyT =
(4/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -161,13 +161,13 @@ let typeShift d tyT = typeShiftAbove d 0 tyT
 let bindingshift d bind =
   match bind with
     NameBind -> NameBind
+  | TyVarBind -> TyVarBind
   | TmAbbBind(t,tyT_opt) ->
      let tyT_opt' = match tyT_opt with
                       None->None
                     | Some(tyT) -> Some(typeShift d tyT) in
      TmAbbBind(termShift d t, tyT_opt')
   | VarBind(tyT) -> VarBind(typeShift d tyT)
-  | TyVarBind -> TyVarBind
   | TyAbbBind(tyT) -> TyAbbBind(typeShift d tyT)

 (* ---------------------------------------------------------------------- *)
(5/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -225,24 +225,24 @@ let tmInfo t = match t with
   | TmTrue(fi) -> fi
   | TmFalse(fi) -> fi
   | TmIf(fi,_,_,_) -> fi
+  | TmTag(fi,_,_,_) -> fi
+  | TmCase(fi,_,_) -> fi
   | TmVar(fi,_,_) -> fi
+  | TmAbs(fi,_,_,_) -> fi
+  | TmApp(fi, _, _) -> fi
+  | TmLet(fi,_,_,_) -> fi
+  | TmFix(fi,_) -> fi
   | TmString(fi,_) -> fi
+  | TmUnit(fi) -> fi
   | TmAscribe(fi,_,_) -> fi
   | TmProj(fi,_,_) -> fi
   | TmRecord(fi,_) -> fi
-  | TmAbs(fi,_,_,_) -> fi
-  | TmApp(fi, _, _) -> fi
   | TmFloat(fi,_) -> fi
   | TmTimesfloat(fi,_,_) -> fi
   | TmZero(fi) -> fi
   | TmSucc(fi,_) -> fi
   | TmPred(fi,_) -> fi
   | TmIsZero(fi,_) -> fi
-  | TmTag(fi,_,_,_) -> fi
-  | TmCase(fi,_,_) -> fi
-  | TmLet(fi,_,_,_) -> fi
-  | TmUnit(fi) -> fi
-  | TmFix(fi,_) -> fi

 (* ---------------------------------------------------------------------- *)
 (* Printing *)
(6/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -291,21 +291,7 @@ and printty_ArrowType outer ctx  tyT = match tyT with
   | tyT -> printty_AType outer ctx tyT

 and printty_AType outer ctx tyT = match tyT with
-    TyString -> pr "String"
-  | TyRecord(fields) ->
-        let pf i (li,tyTi) =
-          if (li <> ((string_of_int i))) then (pr li; pr ":");
-          printty_Type false ctx tyTi
-        in let rec p i l = match l with
-            [] -> ()
-          | [f] -> pf i f
-          | f::rest ->
-              pf i f; pr","; if outer then print_space() else break();
-              p (i+1) rest
-        in pr "{"; open_hovbox 0; p 1 fields; pr "}"; cbox()
-  | TyId(b) -> pr b
-  | TyFloat -> pr "Float"
-  | TyVar(x,n) ->
+    TyVar(x,n) ->
       if ctxlength ctx = n then
         pr (index2name dummyinfo ctx x)
       else
(7/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -313,8 +299,8 @@ and printty_AType outer ctx tyT = match tyT with
             ^ " in {"
             ^ (List.fold_left (fun s (x,_) -> s ^ " " ^ x) "" ctx)
             ^ " }]")
+  | TyId(b) -> pr b
   | TyBool -> pr "Bool"
-  | TyNat -> pr "Nat"
   | TyVariant(fields) ->
         let pf i (li,tyTi) =
           if (li <> ((string_of_int i))) then (pr li; pr ":");
(8/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -326,7 +312,21 @@ and printty_AType outer ctx tyT = match tyT with
               pf i f; pr","; if outer then print_space() else break();
               p (i+1) rest
         in pr "<"; open_hovbox 0; p 1 fields; pr ">"; cbox()
+  | TyString -> pr "String"
   | TyUnit -> pr "Unit"
+  | TyRecord(fields) ->
+        let pf i (li,tyTi) =
+          if (li <> ((string_of_int i))) then (pr li; pr ":");
+          printty_Type false ctx tyTi
+        in let rec p i l = match l with
+            [] -> ()
+          | [f] -> pf i f
+          | f::rest ->
+              pf i f; pr","; if outer then print_space() else break();
+              p (i+1) rest
+        in pr "{"; open_hovbox 0; p 1 fields; pr "}"; cbox()
+  | TyFloat -> pr "Float"
+  | TyNat -> pr "Nat"
   | tyT -> pr "("; printty_Type outer ctx tyT; pr ")"

 let printty ctx tyT = printty_Type true ctx tyT
(9/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,s,e,?]? y
@@ -343,13 +343,6 @@ let rec printtm_Term outer ctx t = match t with
        pr "else ";
        printtm_Term false ctx t3;
        cbox()
-  | TmAbs(fi,x,tyT1,t2) ->
-      (let (ctx',x') = (pickfreshname ctx x) in
-         obox(); pr "lambda ";
-         pr x'; pr ":"; printty_Type false ctx tyT1; pr ".";
-         if (small t2) && not outer then break() else print_space();
-         printtm_Term outer ctx' t2;
-         cbox())
   | TmCase(_, t, cases) ->
       obox();
       pr "case "; printtm_Term false ctx t; pr " of";
(10/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -363,6 +356,13 @@ let rec printtm_Term outer ctx t = match t with
           | c::rest -> pc c; print_space(); pr "| "; p rest
       in p cases;
       cbox()
+  | TmAbs(fi,x,tyT1,t2) ->
+      (let (ctx',x') = (pickfreshname ctx x) in
+         obox(); pr "lambda ";
+         pr x'; pr ":"; printty_Type false ctx tyT1; pr ".";
+         if (small t2) && not outer then break() else print_space();
+         printtm_Term outer ctx' t2;
+         cbox())
   | TmLet(fi, x, t1, t2) ->
        obox0();
        pr "let "; pr x; pr " = ";
(11/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -411,6 +411,12 @@ and printtm_ATerm outer ctx t = match t with
     TmInert(_,tyT) -> pr "inert["; printty_Type false ctx tyT; pr "]"
   | TmTrue(_) -> pr "true"
   | TmFalse(_) -> pr "false"
+  | TmTag(fi, l, t, tyT) ->
+      obox();
+      pr "<"; pr l; pr "="; printtm_Term false ctx t; pr ">";
+      print_space();
+      pr "as "; printty_Type outer ctx tyT;
+      cbox();
   | TmVar(fi,x,n) ->
       if ctxlength ctx = n then
         pr (index2name fi ctx x)
(12/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -420,6 +426,7 @@ and printtm_ATerm outer ctx t = match t with
             ^ (List.fold_left (fun s (x,_) -> s ^ " " ^ x) "" ctx)
             ^ " }]")
   | TmString(_,s) -> pr ("\"" ^ s ^ "\"")
+  | TmUnit(_) -> pr "unit"
   | TmRecord(fi, fields) ->
        let pf i (li,ti) =
          if (li <> ((string_of_int i))) then (pr li; pr "=");
(13/14) Stage this hunk [y,n,q,a,d,K,j,J,g,/,e,?]? y
@@ -440,22 +447,15 @@ and printtm_ATerm outer ctx t = match t with
        | TmSucc(_,s) -> f (n+1) s
        | _ -> (pr "(succ "; printtm_ATerm false ctx t1; pr ")")
      in f 1 t1
-  | TmTag(fi, l, t, tyT) ->
-      obox();
-      pr "<"; pr l; pr "="; printtm_Term false ctx t; pr ">";
-      print_space();
-      pr "as "; printty_Type outer ctx tyT;
-      cbox();
-  | TmUnit(_) -> pr "unit"
   | t -> pr "("; printtm_Term outer ctx t; pr ")"

 let printtm ctx t = printtm_Term true ctx t

 let prbinding ctx b = match b with
     NameBind -> ()
-  | TmAbbBind(t,tyT) -> pr "= "; printtm ctx t
-  | VarBind(tyT) -> pr ": "; printty ctx tyT
   | TyVarBind -> ()
+  | VarBind(tyT) -> pr ": "; printty ctx tyT
+  | TmAbbBind(t,tyT) -> pr "= "; printtm ctx t
   | TyAbbBind(tyT) -> pr "= "; printty ctx tyT


(14/14) Stage this hunk [y,n,q,a,d,K,g,/,s,e,?]? y
<stdin>:216: trailing whitespace.
          if (li <> ((string_of_int i))) then (pr li; pr ":");
<stdin>:217: trailing whitespace.
          printty_Type false ctx tyTi
<stdin>:218: trailing whitespace.
        in let rec p i l = match l with
<stdin>:222: trailing whitespace.
              pf i f; pr","; if outer then print_space() else break();
warning: 4 lines add whitespace errors.

diff --git a/fullequirec/syntax.mli b/fullequirec/syntax.mli
index cedab85..717221c 100644
--- a/fullequirec/syntax.mli
+++ b/fullequirec/syntax.mli
@@ -5,29 +5,34 @@ open Support.Error

 (* Data type definitions *)
 type ty =
-    TyId of string
-  | TyVar of int * int
-  | TyRecord of (string * ty) list
+    TyVar of int * int
+  | TyId of string
   | TyArr of ty * ty
-  | TyFloat
+  | TyUnit
+  | TyRecord of (string * ty) list
   | TyRec of string * ty
-  | TyNat
   | TyVariant of (string * ty) list
-  | TyString
   | TyBool
-  | TyUnit
+  | TyString
+  | TyFloat
+  | TyNat

 type term =
     TmTrue of info
   | TmFalse of info
   | TmIf of info * term * term * term
+  | TmCase of info * term * (string * (string * term)) list
+  | TmTag of info * string * term * ty
   | TmVar of info * int * int
+  | TmAbs of info * string * ty * term
+  | TmApp of info * term * term
+  | TmLet of info * string * term * term
+  | TmFix of info * term
   | TmString of info * string
+  | TmUnit of info
   | TmAscribe of info * term * ty
   | TmRecord of info * (string * term) list
   | TmProj of info * term * string
-  | TmAbs of info * string * ty * term
-  | TmApp of info * term * term
   | TmFloat of info * float
   | TmTimesfloat of info * term * term
   | TmZero of info
(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,s,e,?]? y
@@ -35,17 +40,12 @@ type term =
   | TmPred of info * term
   | TmIsZero of info * term
   | TmInert of info * ty
-  | TmCase of info * term * (string * (string * term)) list
-  | TmTag of info * string * term * ty
-  | TmLet of info * string * term * term
-  | TmUnit of info
-  | TmFix of info * term

 type binding =
     NameBind
-  | TmAbbBind of term * (ty option)
-  | VarBind of ty
   | TyVarBind
+  | VarBind of ty
+  | TmAbbBind of term * (ty option)
   | TyAbbBind of ty

 type command =
(2/2) Stage this hunk [y,n,q,a,d,K,g,/,s,e,?]? y

diff --git a/fullsimple/syntax.ml b/fullsimple/syntax.ml
index 3e33233..a36fcf8 100644
--- a/fullsimple/syntax.ml
+++ b/fullsimple/syntax.ml
@@ -240,7 +240,7 @@ let tmInfo t = match t with
   | TmZero(fi) -> fi
   | TmSucc(fi,_) -> fi
   | TmPred(fi,_) -> fi
-  | TmIsZero(fi,_) -> fi
+  | TmIsZero(fi,_) -> fi

 (* ---------------------------------------------------------------------- *)
 (* Printing *)
(1/1) Stage this hunk [y,n,q,a,d,e,?]? y

22:38:26 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git diff --name-status
22:38:30 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git diff --name-status --cached
M       fullequirec/syntax.ml
M       fullequirec/syntax.mli
M       fullsimple/syntax.ml
22:38:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git commit -v --amend
[ocaml 4ebf4fa] fullequirec: Rearrange order for easier diffing with fullsimple
 Date: Tue Feb 15 22:28:29 2022 +0100
 5 files changed, 163 insertions(+), 163 deletions(-)
22:38:40 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
22:38:41 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:39:28 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:40:33 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 3b642df..7fc9d5f 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -150,41 +150,42 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
-     | (TyRec(x,tyS1),_) ->
-          tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
-     | (_,TyRec(x,tyT1)) ->
-          tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
-     | (TyId(b1),TyId(b2)) -> b1=b2
-     | (TyVar(i,_), _) when istyabb ctx i ->
-         tyeqv seen ctx (gettyabb ctx i) tyT
-     | (_, TyVar(i,_)) when istyabb ctx i ->
-         tyeqv seen ctx tyS (gettyabb ctx i)
-     | (TyVar(i,_),TyVar(j,_)) -> i=j
-     | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
-          (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
-     | (TyBool,TyBool) -> true
-     | (TyNat,TyNat) -> true
-     | (TyRecord(fields1),TyRecord(fields2)) ->
-          List.length fields1 = List.length fields2
-          &&
-          List.for_all
-            (fun (li2,tyTi2) ->
-               try let (tyTi1) = List.assoc li2 fields1 in
-                   tyeqv seen ctx tyTi1 tyTi2
-               with Not_found -> false)
-            fields2
-     | (TyVariant(fields1),TyVariant(fields2)) ->
-          (List.length fields1 = List.length fields2)
-          && List.for_all2
-               (fun (li1,tyTi1) (li2,tyTi2) ->
-                  (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
-               fields1 fields2
-     | (TyUnit,TyUnit) -> true
-     | _ -> false
+
+
+  match (tyS,tyT) with
+    (TyString,TyString) -> true
+  | (TyUnit,TyUnit) -> true
+  | (TyRec(x,tyS1),_) ->
+       tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
22:40:37 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ -^C
^[[A22:40:38 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff -w
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 3b642df..7fc9d5f 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -150,15 +150,17 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
+
+
+  match (tyS,tyT) with
     (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
+  | (TyUnit,TyUnit) -> true
   | (TyRec(x,tyS1),_) ->
        tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
   | (_,TyRec(x,tyT1)) ->
        tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
   | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
   | (TyVar(i,_), _) when istyabb ctx i ->
       tyeqv seen ctx (gettyabb ctx i) tyT
   | (_, TyVar(i,_)) when istyabb ctx i ->
@@ -183,7 +185,6 @@ let rec tyeqv seen ctx tyS tyT =
             (fun (li1,tyTi1) (li2,tyTi2) ->
                (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
             fields1 fields2
-     | (TyUnit,TyUnit) -> true
   | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT
22:40:39 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 3b642df..7fc9d5f 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -150,41 +150,42 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
-     | (TyRec(x,tyS1),_) ->
-          tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
-     | (_,TyRec(x,tyT1)) ->
-          tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
-     | (TyId(b1),TyId(b2)) -> b1=b2
-     | (TyVar(i,_), _) when istyabb ctx i ->
-         tyeqv seen ctx (gettyabb ctx i) tyT
-     | (_, TyVar(i,_)) when istyabb ctx i ->
-         tyeqv seen ctx tyS (gettyabb ctx i)
-     | (TyVar(i,_),TyVar(j,_)) -> i=j
-     | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
-          (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
-     | (TyBool,TyBool) -> true
-     | (TyNat,TyNat) -> true
-     | (TyRecord(fields1),TyRecord(fields2)) ->
-          List.length fields1 = List.length fields2
-          &&
-          List.for_all
-            (fun (li2,tyTi2) ->
-               try let (tyTi1) = List.assoc li2 fields1 in
-                   tyeqv seen ctx tyTi1 tyTi2
-               with Not_found -> false)
-            fields2
-     | (TyVariant(fields1),TyVariant(fields2)) ->
-          (List.length fields1 = List.length fields2)
-          && List.for_all2
-               (fun (li1,tyTi1) (li2,tyTi2) ->
-                  (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
-               fields1 fields2
-     | (TyUnit,TyUnit) -> true
-     | _ -> false
+
+
+  match (tyS,tyT) with
+    (TyString,TyString) -> true
+  | (TyUnit,TyUnit) -> true
+  | (TyRec(x,tyS1),_) ->
+       tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
+  | (_,TyRec(x,tyT1)) ->
+       tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
+  | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
+  | (TyVar(i,_), _) when istyabb ctx i ->
+      tyeqv seen ctx (gettyabb ctx i) tyT
+  | (_, TyVar(i,_)) when istyabb ctx i ->
+      tyeqv seen ctx tyS (gettyabb ctx i)
+  | (TyVar(i,_),TyVar(j,_)) -> i=j
+  | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
+       (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
+  | (TyBool,TyBool) -> true
+  | (TyNat,TyNat) -> true
+  | (TyRecord(fields1),TyRecord(fields2)) ->
+       List.length fields1 = List.length fields2
+       &&
+       List.for_all
+         (fun (li2,tyTi2) ->
+            try let (tyTi1) = List.assoc li2 fields1 in
+                tyeqv seen ctx tyTi1 tyTi2
+            with Not_found -> false)
+         fields2
+  | (TyVariant(fields1),TyVariant(fields2)) ->
+       (List.length fields1 = List.length fields2)
+       && List.for_all2
+            (fun (li1,tyTi1) (li2,tyTi2) ->
+               (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
+            fields1 fields2
+  | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT

(1/1) Stage this hunk [y,n,q,a,d,e,?]? s
Sorry, cannot split this hunk
@@ -150,41 +150,42 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
-     | (TyRec(x,tyS1),_) ->
-          tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
-     | (_,TyRec(x,tyT1)) ->
-          tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
-     | (TyId(b1),TyId(b2)) -> b1=b2
-     | (TyVar(i,_), _) when istyabb ctx i ->
-         tyeqv seen ctx (gettyabb ctx i) tyT
-     | (_, TyVar(i,_)) when istyabb ctx i ->
-         tyeqv seen ctx tyS (gettyabb ctx i)
-     | (TyVar(i,_),TyVar(j,_)) -> i=j
-     | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
-          (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
-     | (TyBool,TyBool) -> true
-     | (TyNat,TyNat) -> true
-     | (TyRecord(fields1),TyRecord(fields2)) ->
-          List.length fields1 = List.length fields2
-          &&
-          List.for_all
-            (fun (li2,tyTi2) ->
-               try let (tyTi1) = List.assoc li2 fields1 in
-                   tyeqv seen ctx tyTi1 tyTi2
-               with Not_found -> false)
-            fields2
-     | (TyVariant(fields1),TyVariant(fields2)) ->
-          (List.length fields1 = List.length fields2)
-          && List.for_all2
-               (fun (li1,tyTi1) (li2,tyTi2) ->
-                  (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
-               fields1 fields2
-     | (TyUnit,TyUnit) -> true
-     | _ -> false
+
+
+  match (tyS,tyT) with
+    (TyString,TyString) -> true
+  | (TyUnit,TyUnit) -> true
+  | (TyRec(x,tyS1),_) ->
+       tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
+  | (_,TyRec(x,tyT1)) ->
+       tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
+  | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
+  | (TyVar(i,_), _) when istyabb ctx i ->
+      tyeqv seen ctx (gettyabb ctx i) tyT
+  | (_, TyVar(i,_)) when istyabb ctx i ->
+      tyeqv seen ctx tyS (gettyabb ctx i)
+  | (TyVar(i,_),TyVar(j,_)) -> i=j
+  | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
+       (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
+  | (TyBool,TyBool) -> true
+  | (TyNat,TyNat) -> true
+  | (TyRecord(fields1),TyRecord(fields2)) ->
+       List.length fields1 = List.length fields2
+       &&
+       List.for_all
+         (fun (li2,tyTi2) ->
+            try let (tyTi1) = List.assoc li2 fields1 in
+                tyeqv seen ctx tyTi1 tyTi2
+            with Not_found -> false)
+         fields2
+  | (TyVariant(fields1),TyVariant(fields2)) ->
+       (List.length fields1 = List.length fields2)
+       && List.for_all2
+            (fun (li1,tyTi1) (li2,tyTi2) ->
+               (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
+            fields1 fields2
+  | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT

(1/1) Stage this hunk [y,n,q,a,d,e,?]? s
Sorry, cannot split this hunk
@@ -150,41 +150,42 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
-     | (TyRec(x,tyS1),_) ->
-          tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
-     | (_,TyRec(x,tyT1)) ->
-          tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
-     | (TyId(b1),TyId(b2)) -> b1=b2
-     | (TyVar(i,_), _) when istyabb ctx i ->
-         tyeqv seen ctx (gettyabb ctx i) tyT
-     | (_, TyVar(i,_)) when istyabb ctx i ->
-         tyeqv seen ctx tyS (gettyabb ctx i)
-     | (TyVar(i,_),TyVar(j,_)) -> i=j
-     | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
-          (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
-     | (TyBool,TyBool) -> true
-     | (TyNat,TyNat) -> true
-     | (TyRecord(fields1),TyRecord(fields2)) ->
-          List.length fields1 = List.length fields2
-          &&
-          List.for_all
-            (fun (li2,tyTi2) ->
-               try let (tyTi1) = List.assoc li2 fields1 in
-                   tyeqv seen ctx tyTi1 tyTi2
-               with Not_found -> false)
-            fields2
-     | (TyVariant(fields1),TyVariant(fields2)) ->
-          (List.length fields1 = List.length fields2)
-          && List.for_all2
-               (fun (li1,tyTi1) (li2,tyTi2) ->
-                  (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
-               fields1 fields2
-     | (TyUnit,TyUnit) -> true
-     | _ -> false
+
+
+  match (tyS,tyT) with
+    (TyString,TyString) -> true
+  | (TyUnit,TyUnit) -> true
+  | (TyRec(x,tyS1),_) ->
+       tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
+  | (_,TyRec(x,tyT1)) ->
+       tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
+  | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
+  | (TyVar(i,_), _) when istyabb ctx i ->
+      tyeqv seen ctx (gettyabb ctx i) tyT
+  | (_, TyVar(i,_)) when istyabb ctx i ->
+      tyeqv seen ctx tyS (gettyabb ctx i)
+  | (TyVar(i,_),TyVar(j,_)) -> i=j
+  | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
+       (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
+  | (TyBool,TyBool) -> true
+  | (TyNat,TyNat) -> true
+  | (TyRecord(fields1),TyRecord(fields2)) ->
+       List.length fields1 = List.length fields2
+       &&
+       List.for_all
+         (fun (li2,tyTi2) ->
+            try let (tyTi1) = List.assoc li2 fields1 in
+                tyeqv seen ctx tyTi1 tyTi2
+            with Not_found -> false)
+         fields2
+  | (TyVariant(fields1),TyVariant(fields2)) ->
+       (List.length fields1 = List.length fields2)
+       && List.for_all2
+            (fun (li1,tyTi1) (li2,tyTi2) ->
+               (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
+            fields1 fields2
+  | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT

(1/1) Stage this hunk [y,n,q,a,d,e,?]? s
Sorry, cannot split this hunk
@@ -150,41 +150,42 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
-     | (TyRec(x,tyS1),_) ->
-          tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
-     | (_,TyRec(x,tyT1)) ->
-          tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
-     | (TyId(b1),TyId(b2)) -> b1=b2
-     | (TyVar(i,_), _) when istyabb ctx i ->
-         tyeqv seen ctx (gettyabb ctx i) tyT
-     | (_, TyVar(i,_)) when istyabb ctx i ->
-         tyeqv seen ctx tyS (gettyabb ctx i)
-     | (TyVar(i,_),TyVar(j,_)) -> i=j
-     | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
-          (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
-     | (TyBool,TyBool) -> true
-     | (TyNat,TyNat) -> true
-     | (TyRecord(fields1),TyRecord(fields2)) ->
-          List.length fields1 = List.length fields2
-          &&
-          List.for_all
-            (fun (li2,tyTi2) ->
-               try let (tyTi1) = List.assoc li2 fields1 in
-                   tyeqv seen ctx tyTi1 tyTi2
-               with Not_found -> false)
-            fields2
-     | (TyVariant(fields1),TyVariant(fields2)) ->
-          (List.length fields1 = List.length fields2)
-          && List.for_all2
-               (fun (li1,tyTi1) (li2,tyTi2) ->
-                  (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
-               fields1 fields2
-     | (TyUnit,TyUnit) -> true
-     | _ -> false
+
+
+  match (tyS,tyT) with
+    (TyString,TyString) -> true
+  | (TyUnit,TyUnit) -> true
+  | (TyRec(x,tyS1),_) ->
+       tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
+  | (_,TyRec(x,tyT1)) ->
+       tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
+  | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
+  | (TyVar(i,_), _) when istyabb ctx i ->
+      tyeqv seen ctx (gettyabb ctx i) tyT
+  | (_, TyVar(i,_)) when istyabb ctx i ->
+      tyeqv seen ctx tyS (gettyabb ctx i)
+  | (TyVar(i,_),TyVar(j,_)) -> i=j
+  | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
+       (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
+  | (TyBool,TyBool) -> true
+  | (TyNat,TyNat) -> true
+  | (TyRecord(fields1),TyRecord(fields2)) ->
+       List.length fields1 = List.length fields2
+       &&
+       List.for_all
+         (fun (li2,tyTi2) ->
+            try let (tyTi1) = List.assoc li2 fields1 in
+                tyeqv seen ctx tyTi1 tyTi2
+            with Not_found -> false)
+         fields2
+  | (TyVariant(fields1),TyVariant(fields2)) ->
+       (List.length fields1 = List.length fields2)
+       && List.for_all2
+            (fun (li1,tyTi1) (li2,tyTi2) ->
+               (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
+            fields1 fields2
+  | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT

(1/1) Stage this hunk [y,n,q,a,d,e,?]? s
Sorry, cannot split this hunk
@@ -150,41 +150,42 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
-     | (TyRec(x,tyS1),_) ->
-          tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
-     | (_,TyRec(x,tyT1)) ->
-          tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
-     | (TyId(b1),TyId(b2)) -> b1=b2
-     | (TyVar(i,_), _) when istyabb ctx i ->
-         tyeqv seen ctx (gettyabb ctx i) tyT
-     | (_, TyVar(i,_)) when istyabb ctx i ->
-         tyeqv seen ctx tyS (gettyabb ctx i)
-     | (TyVar(i,_),TyVar(j,_)) -> i=j
-     | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
-          (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
-     | (TyBool,TyBool) -> true
-     | (TyNat,TyNat) -> true
-     | (TyRecord(fields1),TyRecord(fields2)) ->
-          List.length fields1 = List.length fields2
-          &&
-          List.for_all
-            (fun (li2,tyTi2) ->
-               try let (tyTi1) = List.assoc li2 fields1 in
-                   tyeqv seen ctx tyTi1 tyTi2
-               with Not_found -> false)
-            fields2
-     | (TyVariant(fields1),TyVariant(fields2)) ->
-          (List.length fields1 = List.length fields2)
-          && List.for_all2
-               (fun (li1,tyTi1) (li2,tyTi2) ->
-                  (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
-               fields1 fields2
-     | (TyUnit,TyUnit) -> true
-     | _ -> false
+
+
+  match (tyS,tyT) with
+    (TyString,TyString) -> true
+  | (TyUnit,TyUnit) -> true
+  | (TyRec(x,tyS1),_) ->
+       tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
+  | (_,TyRec(x,tyT1)) ->
+       tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
+  | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
+  | (TyVar(i,_), _) when istyabb ctx i ->
+      tyeqv seen ctx (gettyabb ctx i) tyT
+  | (_, TyVar(i,_)) when istyabb ctx i ->
+      tyeqv seen ctx tyS (gettyabb ctx i)
+  | (TyVar(i,_),TyVar(j,_)) -> i=j
+  | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
+       (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
+  | (TyBool,TyBool) -> true
+  | (TyNat,TyNat) -> true
+  | (TyRecord(fields1),TyRecord(fields2)) ->
+       List.length fields1 = List.length fields2
+       &&
+       List.for_all
+         (fun (li2,tyTi2) ->
+            try let (tyTi1) = List.assoc li2 fields1 in
+                tyeqv seen ctx tyTi1 tyTi2
+            with Not_found -> false)
+         fields2
+  | (TyVariant(fields1),TyVariant(fields2)) ->
+       (List.length fields1 = List.length fields2)
+       && List.for_all2
+            (fun (li1,tyTi1) (li2,tyTi2) ->
+               (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
+            fields1 fields2
+  | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT

(1/1) Stage this hunk [y,n,q,a,d,e,?]? q

22:40:50 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p -w
error: unknown switch `w'
usage: git add [<options>] [--] <pathspec>...

    -n, --dry-run         dry run
    -v, --verbose         be verbose

    -i, --interactive     interactive picking
    -p, --patch           select hunks interactively
    -e, --edit            edit current diff and apply
    -f, --force           allow adding otherwise ignored files
    -u, --update          update tracked files
    --renormalize         renormalize EOL of tracked files (implies -u)
    -N, --intent-to-add   record only the fact that the path will be added later
    -A, --all             add changes from all tracked and untracked files
    --ignore-removal      ignore paths removed in the working tree (same as --no-all)
    --refresh             don't add, only refresh the index
    --ignore-errors       just skip files which cannot be added because of errors
    --ignore-missing      check if - even missing - files are ignored in dry run
    --chmod (+|-)x        override the executable bit of the listed files
    --pathspec-from-file <file>
                          read pathspec from file
    --pathspec-file-nul   with --pathspec-from-file, pathspec elements are separated with NUL character

22:40:51 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff -w
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 3b642df..7fc9d5f 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -150,15 +150,17 @@ let rec simplifyty ctx tyT =
   with NoRuleApplies -> tyT

 let rec tyeqv seen ctx tyS tyT =
-  List.mem (tyS,tyT) seen
-  || match (tyS,tyT) with
+
+
+  match (tyS,tyT) with
     (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
+  | (TyUnit,TyUnit) -> true
   | (TyRec(x,tyS1),_) ->
        tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
   | (_,TyRec(x,tyT1)) ->
        tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
   | (TyId(b1),TyId(b2)) -> b1=b2
+  | (TyFloat,TyFloat) -> true
   | (TyVar(i,_), _) when istyabb ctx i ->
       tyeqv seen ctx (gettyabb ctx i) tyT
   | (_, TyVar(i,_)) when istyabb ctx i ->
@@ -183,7 +185,6 @@ let rec tyeqv seen ctx tyS tyT =
             (fun (li1,tyTi1) (li2,tyTi2) ->
                (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
             fields1 fields2
-     | (TyUnit,TyUnit) -> true
   | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT
22:40:57 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git reset --hard
HEAD is now at 4ebf4fa fullequirec: Rearrange order for easier diffing with fullsimple
22:42:05 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:42:29 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
+   1 +--136 lines: open Format------------------------------------------------------------------------------------|+   1 +--136 lines: open Format------------------------------------------------------------------------------------
  137   match getbinding dummyinfo ctx i with                                                                      |  137   match getbinding dummyinfo ctx i with
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:43:29 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:43:43 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:44:03 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:44:12 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 3b642df..957d1f7 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -152,13 +152,14 @@ let rec simplifyty ctx tyT =
 let rec tyeqv seen ctx tyS tyT =
   List.mem (tyS,tyT) seen
   || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
+       (TyString,TyString) -> true
+     | (TyUnit,TyUnit) -> true
      | (TyRec(x,tyS1),_) ->
           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
      | (_,TyRec(x,tyT1)) ->
           tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
      | (TyId(b1),TyId(b2)) -> b1=b2
+     | (TyFloat,TyFloat) -> true
      | (TyVar(i,_), _) when istyabb ctx i ->
          tyeqv seen ctx (gettyabb ctx i) tyT
      | (_, TyVar(i,_)) when istyabb ctx i ->
@@ -183,7 +184,6 @@ let rec tyeqv seen ctx tyS tyT =
                (fun (li1,tyTi1) (li2,tyTi2) ->
                   (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
                fields1 fields2
-     | (TyUnit,TyUnit) -> true
      | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT
22:44:13 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 3b642df..957d1f7 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -152,13 +152,14 @@ let rec simplifyty ctx tyT =
 let rec tyeqv seen ctx tyS tyT =
   List.mem (tyS,tyT) seen
   || match (tyS,tyT) with
-        (TyString,TyString) -> true
-     | (TyFloat,TyFloat) -> true
+       (TyString,TyString) -> true
+     | (TyUnit,TyUnit) -> true
      | (TyRec(x,tyS1),_) ->
           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
      | (_,TyRec(x,tyT1)) ->
           tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
      | (TyId(b1),TyId(b2)) -> b1=b2
+     | (TyFloat,TyFloat) -> true
      | (TyVar(i,_), _) when istyabb ctx i ->
          tyeqv seen ctx (gettyabb ctx i) tyT
      | (_, TyVar(i,_)) when istyabb ctx i ->
(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,s,e,?]? y
@@ -183,7 +184,6 @@ let rec tyeqv seen ctx tyS tyT =
                (fun (li1,tyTi1) (li2,tyTi2) ->
                   (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)
                fields1 fields2
-     | (TyUnit,TyUnit) -> true
      | _ -> false

 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT
(2/2) Stage this hunk [y,n,q,a,d,K,g,/,e,?]? y

22:44:22 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ make
ocamlc -c  core.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
22:44:24 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
mylist : NatList
10 : Nat
22:44:26 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git commit -v --amend
[ocaml 2d27254] fullequirec: Rearrange order for easier diffing with fullsimple
 Date: Tue Feb 15 22:28:29 2022 +0100
 6 files changed, 166 insertions(+), 166 deletions(-)
22:44:35 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff main.ml ../fullsimple/main.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:44:55 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p
diff --git a/fullequirec/main.ml b/fullequirec/main.ml
index 9866f7d..94f1097 100644
--- a/fullequirec/main.ml
+++ b/fullequirec/main.ml
@@ -63,12 +63,12 @@ let checkbinding fi ctx b = match b with

 let prbindingty ctx b = match b with
     NameBind -> ()
+  | TyVarBind -> ()
   | VarBind(tyT) -> pr ": "; printty ctx tyT
   | TmAbbBind(t, tyT_opt) -> pr ": ";
      (match tyT_opt with
          None -> printty ctx (typeof ctx t)
        | Some(tyT) -> printty ctx tyT)
-  | TyVarBind -> ()
   | TyAbbBind(tyT) -> pr ":: *"

 let rec process_command ctx cmd = match cmd with
(1/1) Stage this hunk [y,n,q,a,d,s,e,?]? y

22:44:58 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git commit -v --amend
[ocaml 8f8e4e6] fullequirec: Rearrange order for easier diffing with fullsimple
 Date: Tue Feb 15 22:28:29 2022 +0100
 7 files changed, 167 insertions(+), 167 deletions(-)
22:45:02 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ l1
Makefile
core.cmi
core.cmo
core.ml
core.mli
f*
lexer.cmi
lexer.cmo
lexer.ml
lexer.mll
main.cmi
main.cmo
main.ml
parser.cmi
parser.cmo
parser.ml
parser.mli
parser.mly
parser.output
support.cmi
support.cmo
support.ml
support.mli
syntax.cmi
syntax.cmo
syntax.ml
syntax.mli
test.f
22:45:05 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ l1 *.ml
core.ml
lexer.ml
main.ml
parser.ml
support.ml
syntax.ml
22:45:08 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff support.ml ../fullsimple/support.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:45:27 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
22:45:28 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
22:45:28 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff lexer.mll ../fullsimple/lexer.mll
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
22:58:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff lexer.mll ../fullsimple/lexer.mll
22:58:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
   45 %token <Support.Error.info> UFLOAT                 |   45 %token <Support.Error.info> UFLOAT
   46 %token <Support.Error.info> REC                    |      ---------------------------------------------------
   47 %token <Support.Error.info> SUCC                   |   46 %token <Support.Error.info> SUCC
   48 %token <Support.Error.info> PRED                   |   47 %token <Support.Error.info> PRED
   49 %token <Support.Error.info> ISZERO                 |   48 %token <Support.Error.info> ISZERO
   50 %token <Support.Error.info> NAT                    |   49 %token <Support.Error.info> NAT
   51                                                    |   50
   52 /* Identifier and constant value tokens */         |   51 /* Identifier and constant value tokens */
+  53 +-- 93 lines: %token <string Support.Error.withinfo|+  52 +-- 93 lines: %token <string Support.Error.withinfo
  146       { fun ctx -> TmAbbBind($2 ctx, None) }       |  145       { fun ctx -> TmAbbBind($2 ctx, None) }
  147                                                    |  146
  148 /* All type expressions */                         |  147 /* All type expressions */
  149 Type :                                             |  148 Type :
  150     ArrowType                                      |  149     ArrowType
  151                 { $1 }                             |  150                 { $1 }
  152   | REC UCID DOT Type                              |      ---------------------------------------------------
  153       { fun ctx ->                                 |      ---------------------------------------------------
  154           let ctx1 = addname ctx $2.v in           |      ---------------------------------------------------
  155           TyRec($2.v,$4 ctx1) }                    |      ---------------------------------------------------
  156                                                    |  151
  157 /* Atomic types are those that never need extra par|  152 /* Atomic types are those that never need extra par
  158 AType :                                            |  153 AType :
  159     LPAREN Type RPAREN                             |  154     LPAREN Type RPAREN
parser.mly                             155,1          18% ../fullsimple/parser.mly               151,0-1        18%
E170: Missing :endfor
Press ENTER or type command to continue
22:59:12 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue 23:03:43 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
  279       cbox()                                                                                                 |      -------------------------------------------------------------------------------------------------------------
  280   | tyT -> printty_ArrowType outer ctx tyT                                                                   |      -------------------------------------------------------------------------------------------------------------
  281 |  273
  282 and printty_ArrowType outer ctx  tyT = match tyT with|  274 and printty_ArrowType outer ctx  tyT = match tyT with
  283     TyArr(tyT1,tyT2) ->|  275     TyArr(tyT1,tyT2) ->
  284       obox0();|  276       obox0();
  285       printty_AType false ctx tyT1;|  277       printty_AType false ctx tyT1;
  286       if outer then pr " ";|  278       if outer then pr " ";
+ 287 +--175 lines: pr "->";---------------------------------------------------------------------------------------|+ 279 +--175 lines: pr "->";---------------------------------------------------------------------------------------
syntax.ml                                                                                        11,1           All ../fullsimple/syntax.ml                                                                          11,1           All
"../fullsimple/syntax.ml" 453L, 13809C
  107   | TyFloat -> TyFloat                                                                                     |1
  108   | TyBool -> TyBool                                                                                       |1
+ 109 +--159 lines: | TyNat -> TyNat-----------------------------------------------------------------------------|1
  268 let small t =                                                                                              |2
  269   match t with                                                                                             |2
  270     TmVar(_,_,_) -> true                                                                                   |2
  271   | _ -> false                                                                                             |2
  272                                                                                                            |2
  273 let rec printty_Type outer ctx tyT = match tyT with                                                        |2
  274     TyRec(x,tyT) ->                                                                                        |2
  275       let (ctx1,x) = (pickfreshname ctx x) in                                                              |
  276       obox(); pr "Rec "; pr x; pr ".";                                                                     |
  277       print_space ();                                                                                      |
  278       printty_Type outer ctx1 tyT;                                                                         |
  279       cbox()                                                                                               |
  280   | tyT -> printty_ArrowType outer ctx tyT                                                                 |
  281                                                                                                            |2
  282 and printty_ArrowType outer ctx  tyT = match tyT with                                                      |2
  283     TyArr(tyT1,tyT2) ->                                                                                    |2
  284       obox0();                                                                                             |2
  285       printty_AType false ctx tyT1;                                                                        |2
  286       if outer then pr " ";                                                                                |2
+ 287 +--175 lines: pr "->";-------------------------------------------------------------------------------------|2
syntax.ml                                                                                      284,15         Bot <
E170: Missing :endfor
Press ENTER or type command to continue
 275     TyArr(tyT1,tyT2) ->
  284       obox0();                                                                                             |  276       obox0();
  285       printty_AType false ctx tyT1;                                                                        |  277       printty_AType false ctx tyT1;
  286       if outer then pr " ";                                                                                |  278       if outer then pr " ";
+ 287 +--175 lines: pr "->";-------------------------------------------------------------------------------------|+ 279 +--175 lines: pr "->";-----------------------------------------------------------------------------------------
~                                                                                                                |~
~                                                                                                                |~
~                                                                                                                |~
~                                                                                                                |~
  107   | TyFloat -> TyFloat                                                                                     |1
  108   | TyBool -> TyBool                                                                                       |1
+ 109 +--159 lines: | TyNat -> TyNat-----------------------------------------------------------------------------|1
  268 let small t =                                                                                              |2
  269   match t with                                                                                             |2
  270     TmVar(_,_,_) -> true                                                                                   |2
  271   | _ -> false                                                                                             |2
  272                                                                                                            |2
  273 let rec printty_Type outer ctx tyT = match tyT with                                                        |2
  274     TyRec(x,tyT) ->                                                                                        |2
  275       let (ctx1,x) = (pickfreshname ctx x) in                                                              |
  276       obox(); pr "Rec "; pr x; pr ".";                                                                     |
  277       print_space ();                                                                                      |
  278       printty_Type outer ctx1 tyT;                                                                         |
  279       cbox()                                                                                               |
  280   | tyT -> printty_ArrowType outer ctx tyT                                                                 |
  281                                                                                                            |2
  282 and printty_ArrowType outer ctx  tyT = match tyT with                                                      |2
  283     TyArr(tyT1,tyT2) ->                                                                                    |2
  284       obox0();                                                                                             |2
  285       printty_AType false ctx tyT1;                                                                        |2
  286       if outer then pr " ";                                                                                |2
+ 287 +--175 lines: pr "->";-------------------------------------------------------------------------------------|2
syntax.ml                                                                                      282,48         Bot <
:qall
syntax.ml                                                                                      279,12         Bot ../fullsimple/syntax.ml                                                                            273,0-1        Bot
23:03:49 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff syntax.ml ../fullsimple/syntax.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue  23:18:05 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
~                                                                                                                  |~
~                                                                                                                  |~
~                                                                                                                  |~
~                                                                                                                  |~
~                                                                                                                  |~
~                                                                                                                  |~
~                                                                                                                  |~
parser.mly                                                                                       156,0-1        All ../fullsimple/parser.mly                                                                         151,0-1        All
"../fullsimple/parser.mly" 343L, 9649C
23:18:06 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff parser.mly ../fullsimple/parser.mly
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
+   1 +--136 lines: open Format--------------------------|+   1 +--136 lines: open Format--------------------------
  137   match getbinding dummyinfo ctx i with            |  137   match getbinding dummyinfo ctx i with
  138     TyAbbBind(tyT) -> tyT                          |  138     TyAbbBind(tyT) -> tyT
  139   | _ -> raise NoRuleApplies                       |  139   | _ -> raise NoRuleApplies
  140                                                    |  140
  141 let rec computety ctx tyT = match tyT with         |  141 let rec computety ctx tyT = match tyT with
  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i|  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i
  143   | TyRec(x,tyS1) as tyS -> typeSubstTop tyS tyS1  |      ---------------------------------------------------
  144   | _ -> raise NoRuleApplies                       |  143   | _ -> raise NoRuleApplies
  145                                                    |  144
  146 let rec simplifyty ctx tyT =                       |  145 let rec simplifyty ctx tyT =
  147   try                                              |  146   try
  148     let tyT' = computety ctx tyT in                |  147     let tyT' = computety ctx tyT in
  149     simplifyty ctx tyT'                            |  148     simplifyty ctx tyT'
  150   with NoRuleApplies -> tyT                        |  149   with NoRuleApplies -> tyT
  151                                                    |  150
  152 let rec tyeqv seen ctx tyS tyT =                   |  151 let rec tyeqv ctx tyS tyT =
  153   List.mem (tyS,tyT) seen                          |  152   let tyS = simplifyty ctx tyS in
  154   || match (tyS,tyT) with                          |  153   let tyT = simplifyty ctx tyT in
  155        (TyString,TyString) -> true                 |  154   match (tyS,tyT) with
  156      | (TyUnit,TyUnit) -> true                     |  155     (TyString,TyString) -> true
  157      | (TyRec(x,tyS1),_) ->                        |  156   | (TyUnit,TyUnit) -> true
  158           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop|  157   | (TyId(b1),TyId(b2)) -> b1=b2
core.ml                                1,1            Top ../fullsimple/core.ml                  1,1            Top
"../fullsimple/core.ml" 294L, 9666C
Press ENTER or type command to continue
23:39:15 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
  178                    tyeqv seen ctx tyTi1 tyTi2                                                                |  177   | (TyVariant(fields1),TyVariant(fields2)) ->
  179                with Not_found -> false)                                                                      |  178        (List.length fields1 = List.length fields2)
  180             fields2                                                                                          |  179        && List.for_all2
  181      | (TyVariant(fields1),TyVariant(fields2)) ->                                                            |  180             (fun (li1,tyTi1) (li2,tyTi2) ->
  182           (List.length fields1 = List.length fields2)                                                        |  181                (li1=li2) && tyeqv ctx tyTi1 tyTi2)
  183           && List.for_all2                                                                                   |  182             fields1 fields2
  184                (fun (li1,tyTi1) (li2,tyTi2) ->                                                               |  183   | _ -> false
core.ml                                                                                          154,1          Top ../fullsimple/core.ml                                                                            153,1          Top
"../fullsimple/core.ml" 294L, 9666C
Press ENTER or type command to continue 23:39:40 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue00:18:36 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff main.ml ../fullsimple/main.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
00:18:47 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ make
ocamlc -c  main.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
00:18:51 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
+   1 +--136 lines: open Format--------------------------|+   1 +--136 lines: open Format--------------------------
  137   match getbinding dummyinfo ctx i with            |  137   match getbinding dummyinfo ctx i with
  138     TyAbbBind(tyT) -> tyT                          |  138     TyAbbBind(tyT) -> tyT
  139   | _ -> raise NoRuleApplies                       |  139   | _ -> raise NoRuleApplies
  140                                                    |  140
  141 let rec computety ctx tyT = match tyT with         |  141 let rec computety ctx tyT = match tyT with
  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i|  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i
  143   | TyRec(x,tyS1) as tyS -> typeSubstTop tyS tyS1  |      ---------------------------------------------------
  144   | _ -> raise NoRuleApplies                       |  143   | _ -> raise NoRuleApplies
  145                                                    |  144
  146 let rec simplifyty ctx tyT =                       |  145 let rec simplifyty ctx tyT =
  147   try                                              |  146   try
  148     let tyT' = computety ctx tyT in                |  147     let tyT' = computety ctx tyT in
  149     simplifyty ctx tyT'                            |  148     simplifyty ctx tyT'
  150   with NoRuleApplies -> tyT                        |  149   with NoRuleApplies -> tyT
  151                                                    |  150
  152 let rec tyeqv seen ctx tyS tyT =                   |  151 let rec tyeqv ctx tyS tyT =
  153   List.mem (tyS,tyT) seen                          |  152   let tyS = simplifyty ctx tyS in
  154   || match (tyS,tyT) with                          |  153   let tyT = simplifyty ctx tyT in
  155        (TyString,TyString) -> true                 |  154   match (tyS,tyT) with
  156      | (TyUnit,TyUnit) -> true                     |  155     (TyString,TyString) -> true
  157      | (TyRec(x,tyS1),_) ->                        |  156   | (TyUnit,TyUnit) -> true
  158           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop|  157   | (TyId(b1),TyId(b2)) -> b1=b2
core.ml                                143,1          Top ../fullsimple/core.ml                  143,1          Top
"../fullsimple/core.ml" 294L, 9666C
mylist : NatList
10 : Nat
00:18:52 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
  178                    tyeqv seen ctx tyTi1 tyTi2                                                                |  177   | (TyVariant(fields1),TyVariant(fields2)) ->
  179                with Not_found -> false)                                                                      |  178        (List.length fields1 = List.length fields2)
  180             fields2                                                                                          |  179        && List.for_all2
  181      | (TyVariant(fields1),TyVariant(fields2)) ->                                                            |  180             (fun (li1,tyTi1) (li2,tyTi2) ->
  182           (List.length fields1 = List.length fields2)                                                        |  181                (li1=li2) && tyeqv ctx tyTi1 tyTi2)
  183           && List.for_all2                                                                                   |  182             fields1 fields2
  184                (fun (li1,tyTi1) (li2,tyTi2) ->                                                               |  183   | _ -> false
core.ml                                                                                          143,1          Top ../fullsimple/core.ml                                                                            143,1          Top
  174           &&                                                                                               |1
  175           List.for_all                                                                                     |1
  176             (fun (li2,tyTi2) ->                                                                            |1
  177                try let (tyTi1) = List.assoc li2 fields1 in                                                 |1
  178                    tyeqv seen ctx tyTi1 tyTi2                                                              |1
  179                with Not_found -> false)                                                                    |1
  180             fields2                                                                                        |1
  181      | (TyVariant(fields1),TyVariant(fields2)) ->                                                          |1
  182           (List.length fields1 = List.length fields2)                                                      |1
  183           && List.for_all2                                                                                 |1
  184                (fun (li1,tyTi1) (li2,tyTi2) ->                                                             |1
  185                   (li1=li2) && tyeqv seen ctx tyTi1 tyTi2)                                                 |
  186                fields1 fields2                                                                             |
  187      | _ -> false                                                                                          |
  188                                                                                                            |
  189 let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT                                                               |
  190                                                                                                            |1
  191 (* ------------------------   TYPING  ------------------------ *)                                          |1
  192                                                                                                            |1
  193 let rec typeof ctx t =                                                                                     |1
  194   match t with                                                                                             |1
  195     TmInert(fi,tyT) ->                                                                                     |1
+ 196 +--105 lines: tyT------------------------------------------------------------------------------------------|1
core.ml                                                                                        184,16         Bot <
"../fullsimple/core.ml" 294L, 9666C
Press ENTER or type command to continue 00:20:54 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue 00:26:37 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
00:26:50 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
00:26:51 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff core.ml ../fullsimple/core.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
08:14:54 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
+   1 +--114 lines: Module Main: The main program.  Deals|+   1 +--114 lines: Module Main: The main program.  Deals
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
~                                                        |~
main.ml                                1,1            All ../fullsimple/main.ml                  1,1            All
"../fullsimple/main.ml" 114L, 3118C
mylist : NatList
10 : Nat
08:14:56 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff main.ml ../fullsimple/main.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue 08:19:50 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
08:19:51 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff main.ml ../fullsimple/main.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
08:19:57 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ l1
Makefile
core.cmi
core.cmo
core.ml
core.mli
f*
lexer.cmi
lexer.cmo
lexer.ml
lexer.mll
main.cmi
main.cmo
main.ml
parser.cmi
parser.cmo
parser.ml
parser.mli
parser.mly
parser.output
support.cmi
support.cmo
support.ml
support.mli
syntax.cmi
syntax.cmo
syntax.ml
syntax.mli
test.f
08:19:59 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ l1 *.ml
core.ml
lexer.ml
main.ml
parser.ml
support.ml
syntax.ml
08:20:01 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff support.ml ../fullsimple/support.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
08:20:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vimdiff main.ml ../fullsimple/main.ml
2 files to edit
Error detected while processing /Users/erszcz/.vim/bundle/nvim-lspconfig/plugin/lspconfig.vim:
line    6:
E319: Sorry, the command is not available in this version: lua << EOF
line    7:
E492: Not an editor command: lsp_complete_configured_servers = function()
line    8:
E133: :return not inside a function
line    9:
E580: :endif without :if: end
line   10:
E492: Not an editor command: lsp_get_active_client_ids = function()
line   11:
E492: Not an editor command:   client_ids = {}
line   12:
E690: Missing "in" after :for
line   15:
E133: :return not inside a function
line   19:
E170: Missing :endfor
Press ENTER or type command to continue
08:20:41 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
08:20:42 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
08:26:19 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vim core.ml
08:33:14 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
    1 open Format
    2 open Syntax
    3 open Support.Error
    4 open Support.Pervasive
    5
    6 (* ------------------------   EVALUATION  ------------------------ *)
    7
    8 exception NoRuleApplies
    9
   10 let rec isnumericval ctx t = match t with
   11     TmZero(_) -> true
   12   | TmSucc(_,t1) -> isnumericval ctx t1
   13   | _ -> false
   14
   15 let rec isval ctx t = match t with
   16     TmTrue(_)  -> true
   17   | TmFalse(_) -> true
   18   | TmTag(_,l,t1,_) -> isval ctx t1
   19   | TmString _  -> true
   20   | TmUnit(_)  -> true
   21   | TmFloat _  -> true
   22   | t when isnumericval ctx t  -> true
   23   | TmAbs(_,_,_,_) -> true
core.ml                                                                                          1,1            Top
f1 : Nat -> Hungry
f2 : Hungry
  268   | TmString _ -> TyString
  269   | TmUnit(fi) -> TyUnit
  270   | TmAscribe(fi,t1,tyT) ->
  271      if tyeqv ctx (typeof ctx t1) tyT then
  272        tyT
  273      else
  274        error fi "body of as-term does not have the expected type"
  275   | TmRecord(fi, fields) ->
  276       let fieldtys =
  277         List.map (fun (li,ti) -> (li, typeof ctx ti)) fields in
  278       TyRecord(fieldtys)
  279   | TmProj(fi, t1, l) ->
  280       (match simplifyty ctx (typeof ctx t1) with
  281           TyRecord(fieldtys) ->
  282             (try List.assoc l fieldtys
  283              with Not_found -> error fi ("label "^l^" not found"))
  284         | _ -> error fi "Expected record type")
  285   | TmFloat _ -> TyFloat
  286   | TmTimesfloat(fi,t1,t2) ->
  287       if tyeqv ctx (typeof ctx t1) TyFloat
core.ml                                                                                                                                                                                                              263,19         94%
?\<computety\>                                                                                                                                                                                                       [1/2]
  138     TyAbbBind(tyT) -> tyT
  139   | _ -> raise NoRuleApplies
  140
  141 let rec computety ctx tyT = match tyT with
  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i
  143   | TyRec(x,tyS1) as tyS -> typeSubstTop tyS tyS1
  144   | _ -> raise NoRuleApplies
  145
  146 let rec simplifyty ctx tyT =
  147   try
  148     let tyT' = computety ctx tyT in
  149     simplifyty ctx tyT'
  150   with NoRuleApplies -> tyT
  151
  152 let rec tyeqv seen ctx tyS tyT =
  153   List.mem (tyS,tyT) seen
  154   || match (tyS,tyT) with
  155        (TyString,TyString) -> true
  156      | (TyUnit,TyUnit) -> true
  157      | (TyRec(x,tyS1),_) ->
  158           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
  159      | (_,TyRec(x,tyT1)) ->
  160           tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
core.ml                                                                                          141,9          49%
?\<computety\>                                                                                   [1/2]
  159      | (_,TyRec(x,tyT1)) ->
  160           tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
  161      | (TyId(b1),TyId(b2)) -> b1=b2
  162      | (TyFloat,TyFloat) -> true
  163      | (TyVar(i,_), _) when istyabb ctx i ->
  164          tyeqv seen ctx (gettyabb ctx i) tyT
  165      | (_, TyVar(i,_)) when istyabb ctx i ->
  166          tyeqv seen ctx tyS (gettyabb ctx i)
  167      | (TyVar(i,_),TyVar(j,_)) -> i=j
  168      | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
  169           (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
  170      | (TyBool,TyBool) -> true
  171      | (TyNat,TyNat) -> true
  172      | (TyRecord(fields1),TyRecord(fields2)) ->
  173           List.length fields1 = List.length fields2
  174           &&
  175           List.for_all
  176             (fun (li2,tyTi2) ->
  177                try let (tyTi1) = List.assoc li2 fields1 in
  178                    tyeqv seen ctx tyTi1 tyTi2
  179                with Not_found -> false)
  180             fields2
  181      | (TyVariant(fields1),TyVariant(fields2)) ->
  182           (List.length fields1 = List.length fields2)
core.ml [+]                                                                                      141,9          52%
  138     TyAbbBind(tyT) -> tyT
  139   | _ -> raise NoRuleApplies
  140
  141 (*let rec computety ctx tyT = match tyT with*)
  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i
  143   | TyRec(x,tyS1) as tyS -> typeSubstTop tyS tyS1
  144   | _ -> raise NoRuleApplies
  145
  146 let rec simplifyty ctx tyT =
  147   try
  148     let tyT' = computety ctx tyT in
  149     simplifyty ctx tyT'
  150   with NoRuleApplies -> tyT
  151
  152 let rec tyeqv seen ctx tyS tyT =
  153   List.mem (tyS,tyT) seen
  154   || match (tyS,tyT) with
  155        (TyString,TyString) -> true
  156      | (TyUnit,TyUnit) -> true
  157      | (TyRec(x,tyS1),_) ->
  158           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
  159      | (_,TyRec(x,tyT1)) ->
  160           tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
core.ml [+]                                                                                      141,9          49%



























  134   | _ -> false
  135
  136 let gettyabb ctx i =
  137   match getbinding dummyinfo ctx i with
  138     TyAbbBind(tyT) -> tyT
  139   | _ -> raise NoRuleApplies
  140
  141 (*let rec computety ctx tyT = match tyT with*)
  142     TyVar(i,_) when istyabb ctx i -> gettyabb ctx i
  143   | TyRec(x,tyS1) as tyS -> typeSubstTop tyS tyS1
  144   | _ -> raise NoRuleApplies
  145
  146 let rec simplifyty ctx tyT =
  147   try
  148     let tyT' = computety ctx tyT in
  149     simplifyty ctx tyT'
  150   with NoRuleApplies -> tyT
  151
  152 let rec tyeqv seen ctx tyS tyT =
  153   List.mem (tyS,tyT) seen
  154   || match (tyS,tyT) with
  155        (TyString,TyString) -> true
  156      | (TyUnit,TyUnit) -> true
  157      | (TyRec(x,tyS1),_) ->
  158           tyeqv ((tyS,tyT)::seen) ctx (typeSubstTop tyS tyS1) tyT
  159      | (_,TyRec(x,tyT1)) ->
  160           tyeqv ((tyS,tyT)::seen) ctx tyS (typeSubstTop tyT tyT1)
  161      | (TyId(b1),TyId(b2)) -> b1=b2
  162      | (TyFloat,TyFloat) -> true
  163      | (TyVar(i,_), _) when istyabb ctx i ->
  164          tyeqv seen ctx (gettyabb ctx i) tyT
  165      | (_, TyVar(i,_)) when istyabb ctx i ->
  166          tyeqv seen ctx tyS (gettyabb ctx i)
  167      | (TyVar(i,_),TyVar(j,_)) -> i=j
  168      | (TyArr(tyS1,tyS2),TyArr(tyT1,tyT2)) ->
  169           (tyeqv seen ctx tyS1 tyT1) && (tyeqv seen ctx tyS2 tyT2)
  170      | (TyBool,TyBool) -> true
  171      | (TyNat,TyNat) -> true
  172      | (TyRecord(fields1),TyRecord(fields2)) ->
  173           List.length fields1 = List.length fields2
  174           &&
  175           List.for_all
  176             (fun (li2,tyTi2) ->
  177                try let (tyTi1) = List.assoc li2 fields1 in
  178                    tyeqv seen ctx tyTi1 tyTi2
  179                with Not_found -> false)
  180             fields2
  181      | (TyVariant(fields1),TyVariant(fields2)) ->
  182           (List.length fields1 = List.length fields2)
core.ml [+]                                                                                      141,9          52%
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
mylist : NatList
10 : Nat
08:33:18 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vim core.ml
08:50:57 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)$ make clean
rm -rf lexer.ml parser.ml parser.mli *.o *.cmo *.cmi parser.output \
	   f f.exe TAGS *~ *.bak
08:51:00 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml)
$ l1
Makefile
core.ml
core.mli
lexer.mll
main.ml
parser.mly
support.ml
support.mli
syntax.ml
syntax.mli
test.f
08:51:01 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml)
$ make
ocamllex lexer.mll
66 states, 658 transitions, table size 3028 bytes
ocamlyacc -v parser.mly
ocamlc -c  support.mli
ocamlc -c  support.ml
ocamlc -c  syntax.mli
ocamlc -c  syntax.ml
ocamlc -c  core.mli
ocamlc -c  core.ml
ocamlc -c  parser.mli
ocamlc -c  parser.ml
ocamlc -c  lexer.ml
ocamlc -c  main.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
08:51:07 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ ./f
.depend        core.mli       lexer.mll      parser.cmo     support.cmi    syntax.cmo
Makefile       f              main.cmi       parser.ml      support.cmo    syntax.ml
core.cmi       lexer.cmi      main.cmo       parser.mli     support.ml     syntax.mli
core.cmo       lexer.cmo      main.ml        parser.mly     support.mli    test.f
core.ml        lexer.ml       parser.cmi     parser.output  syntax.cmi
08:51:07 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ ./f test.f
"hello" : String
(lambda x:A. x) : A -> A
6.28318 : Float
(lambda x:Bool. x) : Bool -> Bool
true : Bool
(lambda x:Nat. (succ x)) : Nat -> Nat
3 : Nat
T :: *
(lambda f:T. lambda x:Nat. f (f x)) : T -> Nat -> Nat
(lambda f:Rec X. A->A. lambda x:A. f x) : (Rec X. A->A) -> A -> A
{x=true, y=false} : {x:Bool, y:Bool}
true : Bool
{true, false} : {Bool, Bool}
true : Bool
(lambda x:<a:Bool,b:Bool>. x)
  : <a:Bool,b:Bool> -> <a:Bool, b:Bool>
Counter :: *
p : {get:Nat, inc:Unit->Counter}
p1 : Counter
1 : Nat
get : Counter -> Nat
inc : Counter -> Unit -> (Rec P. {get:Nat, inc:Unit->P})
Hungry :: *
f0 : Nat -> Nat -> Hungry
f1 : Nat -> Hungry
f2 : Hungry
T :: *
fix_T : (T->T) -> T
D :: *
fix_D : (D->D) -> D
diverge_D : Unit -> D
lam : (D->D) -> D -> D
ap : D -> D -> (Rec X. X -> X)
myfix : D -> D
true : Bool
unit : Unit
NatList :: *
nil : NatList
cons : Nat -> NatList -> NatList
isnil : NatList -> Bool
hd : NatList -> Nat
tl : NatList -> NatList
plus : Nat -> Nat -> Nat
sumlist : NatList -> Nat
mylist : NatList
10 : Nat
08:51:12 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ vim syntax.ml
08:54:08 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ put
/Users/erszcz/work/erszcz/tapl-erlang/apps/fullequirec/test/test.f -> /Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f
08:54:45 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
  263 let obox0() = open_hvbox 0                           263 let obox0() = open_hvbox 0
  264 let obox() = open_hvbox 2                            264 let obox() = open_hvbox 2
  265 let cbox() = close_box()                             265 let cbox() = close_box()
  266 let break() = print_break 0 0                        266 let break() = print_break 0 0
  267                                                      267
  268 let small t =                                        268 let small t =
  269   match t with                                       269   match t with
  270     TmVar(_,_,_) -> true                             270     TmVar(_,_,_) -> true
  271   | _ -> false                                       271   | _ -> false
  272                                                      272
  273 let rec printty_Type outer ctx tyT = match tyT with  273 let rec printty_Type outer ctx tyT = match tyT with
  274     TyRec(x,tyT) ->                                  274     TyRec(x,tyT) ->
  275       let (ctx1,x) = (pickfreshname ctx x) in        275       let (ctx1,x) = (pickfreshname ctx x) in
  276       obox(); pr "Rec "; pr x; pr ".";               276       obox(); pr "Rec "; pr x; pr ".";
  277       print_space ();                                277       print_space ();
  278       printty_Type outer ctx1 tyT;                   278       printty_Type outer ctx1 tyT;
  279       cbox()                                         279       cbox()
  280   | tyT -> printty_ArrowType outer ctx tyT           280   | tyT -> printty_ArrowType outer ctx tyT
  281                                                      281
  282 and printty_ArrowType outer ctx  tyT = match tyT wi  282 and printty_ArrowType outer ctx  tyT = match tyT wi
  283     TyArr(tyT1,tyT2) ->                              283     TyArr(tyT1,tyT2) ->
fullequirec/syntax.ml                  273,10         59% fullequirec/syntax.ml                  273,9          59%
> fullequirec/core.ml #
 prt  path  <fil>={ buffers }=<mru> <->                                       /Users/erszcz/work/erszcz/tapl-ocaml
>>> _
  263 let obox0() = open_hvbox 0                           263 let obox0() = open_hvbox 0
  264 let obox() = open_hvbox 2                            264 let obox() = open_hvbox 2
  265 let cbox() = close_box()                             265 let cbox() = close_box()
  266 let break() = print_break 0 0                        266 let break() = print_break 0 0
  267                                                      267
  268 let small t =                                        268 let small t =
  269   match t with                                       269   match t with
  270     TmVar(_,_,_) -> true                             270     TmVar(_,_,_) -> true
  271   | _ -> false                                       271   | _ -> false
  272                                                      272
  273 let rec printty_Type outer ctx tyT = match tyT with  273 let rec printty_Type outer ctx tyT = match tyT with
  274     TyRec(x,tyT) ->                                  274     TyRec(x,tyT) ->
  275       let (ctx1,x) = (pickfreshname ctx x) in        275       let (ctx1,x) = (pickfreshname ctx x) in
  276       obox(); pr "Rec "; pr x; pr ".";               276       obox(); pr "Rec "; pr x; pr ".";
  277       print_space ();                                277       print_space ();
  278       printty_Type outer ctx1 tyT;                   278       printty_Type outer ctx1 tyT;
  279       cbox()                                         279       cbox()
  280   | tyT -> printty_ArrowType outer ctx tyT           280   | tyT -> printty_ArrowType outer ctx tyT
  281                                                      281
  282 and printty_ArrowType outer ctx  tyT = match tyT wi  282 and printty_ArrowType outer ctx  tyT = match tyT wit 283     TyArr(tyT1,tyT2) ->                              283     TyArr(tyT1,tyT2) ->
fullequirec/syntax.ml                  273,10         59% fullequirec/syntax.ml                   273,9          59%
> fullequirec/core.ml #
 prt  path  <fil>={ buffers }=<mru> <->                                        /Users/erszcz/work/erszcz/tapl-ocaml
$ ./f test.f
Counter :: *
p : {get:Nat, inc:Unit->Counter}
08:54:48 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ocaml
ocaml               ocamlcp.byte        ocamllex            ocamlobjinfo        ocamlprof.byte
ocaml-syntax-shims  ocamlcp.opt         ocamllex.byte       ocamlobjinfo.byte   ocamlprof.opt
ocamlbuild          ocamldebug          ocamllex.opt        ocamlobjinfo.opt    ocamlrun
ocamlbuild.byte     ocamldep            ocamlmerlin-reason  ocamlopt            ocamlrund
ocamlbuild.native   ocamldep.byte       ocamlmklib          ocamlopt.byte       ocamlruni
ocamlc              ocamldep.opt        ocamlmklib.byte     ocamlopt.opt        ocamlyacc
ocamlc.byte         ocamldoc            ocamlmklib.opt      ocamloptp
ocamlc.opt          ocamldoc.opt        ocamlmktop          ocamloptp.byte
ocamlcmt            ocamlfind           ocamlmktop.byte     ocamloptp.opt
ocamlcp             ocamlformat         ocamlmktop.opt      ocamlprof
08:54:48 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ocaml
        OCaml version 4.11.1

# ^CInterrupted.
# ^CInterrupted.
# ^D
08:55:13 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim core.ml
08:59:09 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ mkae
-bash: mkae: command not found
08:59:10 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
File "core.ml", line 190, characters 8-20:
190 |         printty_Type false ctx tyS; print_endline;
              ^^^^^^^^^^^^
Error: Unbound value printty_Type
make: *** [core.cmo] Error 2
08:59:12 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim main.ml
08:59:55 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
File "core.ml", line 190, characters 8-15:
190 |         printty false ctx tyS; print_endline;
              ^^^^^^^
Error: This function has type Syntax.context -> Syntax.ty -> unit
       It is applied to too many arguments; maybe you forgot a `;'.
make: *** [core.cmo] Error 2
08:59:57 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim main.ml
09:00:26 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
File "core.ml", line 190, characters 25-38:
190 |         printty ctx tyS; print_endline;
                               ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 191, characters 25-38:
191 |         printty ctx tyT; print_endline;
                               ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 193, characters 8-21:
193 |         print_boolean r;
              ^^^^^^^^^^^^^
Error: Unbound value print_boolean
Hint: Did you mean print_bool?
make: *** [core.cmo] Error 2
09:00:28 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim main.ml
09:00:54 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim core.ml
09:01:02 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
File "core.ml", line 190, characters 25-38:
190 |         printty ctx tyS; print_endline;
                               ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 191, characters 25-38:
191 |         printty ctx tyT; print_endline;
                               ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 194, characters 8-21:
194 |         print_endline;
              ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
09:01:04 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ./f test.f
Counter :: *
NatNattrue{x:Nat}{x:Nat}true{x:Nat} ->
                            {get:Nat, inc:Unit->Counter}{x:Nat} ->
                                                        Countertrue{
x:Nat}{x:Nat}truep : {get:Nat, inc:Unit->Counter}
09:01:07 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim core.ml
09:01:46 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
File "core.ml", line 190, characters 25-38:
190 |         printty ctx tyS; print_endline; print_endline;
                               ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 190, characters 40-53:
190 |         printty ctx tyS; print_endline; print_endline;
                                              ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 191, characters 25-38:
191 |         printty ctx tyT; print_endline; print_endline;
                               ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 191, characters 40-53:
191 |         printty ctx tyT; print_endline; print_endline;
                                              ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 194, characters 8-21:
194 |         print_endline; print_endline;
              ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
File "core.ml", line 194, characters 23-36:
194 |         print_endline; print_endline;
                             ^^^^^^^^^^^^^
Warning 10: this expression should have type unit.
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
09:01:48 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ./f test.f
Counter :: *
NatNattrue{x:Nat}{x:Nat}true{x:Nat} ->
                            {get:Nat, inc:Unit->Counter}{x:Nat} ->
                                                        Countertrue{
x:Nat}{x:Nat}truep : {get:Nat, inc:Unit->Counter}
09:01:50 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim core.ml
09:02:33 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
09:02:36 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ./f test.f
Counter :: *






NatNattrue{x:Nat}{x:Nat}true{x:Nat} ->
                            {
get:Nat, inc:Unit->Counter}{x:Nat} ->
                                                        Counter
true
{
x:Nat}
{
x:Nat}true
p : {get:Nat, inc:Unit->Counter}
09:02:38 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim core.ml
09:03:24 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
^[[A^[[AFile "core.ml", line 190, characters 22-39:
190 |         print_endline (printty ctx tyS);
                            ^^^^^^^^^^^^^^^^^
Error: This expression has type unit but an expression was expected of type
         string
make: *** [core.cmo] Error 2
^[[A09:03:27 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ vim core.ml
09:03:44 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ make
ocamlc -c  core.ml
Linking f
ocamlc -o f  support.cmo syntax.cmo core.cmo parser.cmo lexer.cmo main.cmo
09:03:46 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ./f test.f
Counter :: *






NatNattrue{x:Nat}{x:Nat}true{x:Nat} ->
                            {
get:Nat, inc:Unit->Counter}{x:Nat} ->
                                                        Counter
true
{
x:Nat}
{
x:Nat}true
p : {get:Nat, inc:Unit->Counter}
09:03:48 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ocaml
        OCaml version 4.11.1

# #help
  ;;
                              General
#help
  Prints a list of all available directives, with corresponding argument type
  if appropriate.
#quit
  Exit the toplevel.

                              Loading code
#cd <str>
  Change the current working directory.
#directory <str>
  Add the given directory to search path for source and compiled files.
#load <str>
  Load in memory a bytecode object, produced by ocamlc.
#load_rec <str>
  As #load, but loads dependencies recursively.
#mod_use <str>
  Usage is identical to #use but #mod_use wraps the contents in a module.
#remove_directory <str>
  Remove the given directory from the search path.
#use <str>
  Read, compile and execute source phrases from the given file.
#use_output <str>
  Execute a command and read, compile and execute source phrases from its
  output.

                              Environment queries
#show <ident>
  Print the signatures of components from any of the categories below.
#show_class <ident>
  Print the signature of the corresponding class.
#show_class_type <ident>
  Print the signature of the corresponding class type.
#show_constructor <ident>
  Print the signature of the corresponding value constructor.
#show_exception <ident>
  Print the signature of the corresponding exception.
#show_module <ident>
  Print the signature of the corresponding module.
#show_module_type <ident>
  Print the signature of the corresponding module type.
#show_type <ident>
  Print the signature of the corresponding type constructor.
#show_val <ident>
  Print the signature of the corresponding value.

                              Pretty-printing
#install_printer <ident>
  Registers a printer for values of a certain type.
#print_depth <int>
  Limit the printing of values to a maximal depth of n.
#print_length <int>
  Limit the number of value nodes printed to at most n.
#remove_printer <ident>
  Remove the named function from the table of toplevel printers.

                              Tracing
#trace <ident>
  All calls to the function named function-name will be traced.
#untrace <ident>
  Stop tracing the given function.
#untrace_all
  Stop tracing all functions traced so far.

                              Compiler options
#labels <bool>
  Choose whether to ignore labels in function types.
#ppx <str>
  After parsing, pipe the abstract syntax tree through the preprocessor
  command.
#principal <bool>
  Make sure that all types are derived in a principal way.
#rectypes
  Allow arbitrary recursive types during type-checking.
#warn_error <str>
  Treat as errors the warnings enabled by the argument.
#warnings <str>
  Enable or disable warnings according to the argument.

# #load_rec "main";;
Cannot find file main.
# ^CInterrupted.
# ^CInterrupted.
# ^[[A^[[B^CInterrupted.
# ^CInterrupted.
# ^D
09:05:17 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ rlwrap ocaml
        OCaml version 4.11.1

#load_rec "main.cmo";;
Error: You must specify an input file


09:05:25 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ rlwrap ocaml
        OCaml version 4.11.1

# #load_rec "main.cmo" "test.f";;
Error: Syntax error
#load_rec "main.cmo";;
Error: You must specify an input file


09:06:13 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$
g09:10:52 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git diff
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 957d1f7..21e2bf4 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -186,7 +186,13 @@ let rec tyeqv seen ctx tyS tyT =
                fields1 fields2
      | _ -> false

-let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT
+let tyeqv ctx tyS tyT =
+        printty ctx tyS; print_endline "";
+        printty ctx tyT; print_endline "";
+        let r = tyeqv [] ctx tyS tyT in
+        print_bool r;
+        print_endline "";
+        r

 (* ------------------------   TYPING  ------------------------ *)

diff --git a/fullequirec/test.f b/fullequirec/test.f
index 0ed5a28..c17df26 100644
--- a/fullequirec/test.f
+++ b/fullequirec/test.f
@@ -1,37 +1,3 @@
09:10:53 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ git add -p
diff --git a/fullequirec/core.ml b/fullequirec/core.ml
index 957d1f7..21e2bf4 100644
--- a/fullequirec/core.ml
+++ b/fullequirec/core.ml
@@ -186,7 +186,13 @@ let rec tyeqv seen ctx tyS tyT =
                fields1 fields2
      | _ -> false

-let tyeqv ctx tyS tyT = tyeqv [] ctx tyS tyT
+let tyeqv ctx tyS tyT =
+        printty ctx tyS; print_endline "";
+        printty ctx tyT; print_endline "";
+        let r = tyeqv [] ctx tyS tyT in
+        print_bool r;
+        print_endline "";
+        r

 (* ------------------------   TYPING  ------------------------ *)

(1/1) Stage this hunk [y,n,q,a,d,e,?]? y

diff --git a/fullequirec/test.f b/fullequirec/test.f
index 0ed5a28..c17df26 100644
--- a/fullequirec/test.f
+++ b/fullequirec/test.f
@@ -1,37 +1,3 @@
-/* Examples for testing */
-
- "hello";
-
-lambda x:A. x;
-
-timesfloat 2.0 3.14159;
-
-lambda x:Bool. x;
-(lambda x:Bool->Bool. if x false then true else false)
-  (lambda x:Bool. if x then false else true);
-
-lambda x:Nat. succ x;
-(lambda x:Nat. succ (succ x)) (succ 0);
-
-T = Nat->Nat;
-lambda f:T. lambda x:Nat. f (f x);
-
-
-
-lambda f:Rec X.A->A. lambda x:A. f x;
-
-
-{x=true, y=false};
-{x=true, y=false}.x;
-{true, false};
-{true, false}.1;
-
-
-
-lambda x:<a:Bool,b:Bool>. x;
-
-
-
 Counter = Rec P. {get:Nat, inc:Unit->P};

 p =
(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]? y
@@ -43,83 +9,3 @@ let create =
          inc = lambda _:Unit. cr {x=succ(s.x)}})
 in
   create {x=0};
-
-p1 = p.inc unit;
-p1.get;
-
-get = lambda p:Counter. p.get;
-inc = lambda p:Counter. p.inc;
-
-Hungry = Rec A. Nat -> A;
-
-f0 =
-fix
-  (lambda f: Nat->Hungry.
-   lambda n:Nat.
-     f);
-
-f1 = f0 0;
-f2 = f1 2;
-
-T = Nat;
-
-fix_T =
-lambda f:T->T.
-  (lambda x:(Rec A.A->T). f (x x))
-  (lambda x:(Rec A.A->T). f (x x));
-
-D = Rec X. X->X;
-
-fix_D =
-lambda f:D->D.
-  (lambda x:(Rec A.A->D). f (x x))
-  (lambda x:(Rec A.A->D). f (x x));
-
-diverge_D = lambda _:Unit. fix_D (lambda x:D. x);
-
-lam = lambda f:D->D. f;
-ap = lambda f:D. lambda a:D. f a;
-
-myfix = lam (lambda f:D.
-             ap (lam (lambda x:D. ap f (ap x x)))
-                (lam (lambda x:D. ap f (ap x x))));
-
-
-let x=true in x;
-
-unit;
-
-
-NatList = Rec X. <nil:Unit, cons:{Nat,X}>;
-
-nil = <nil=unit> as NatList;
-
-cons = lambda n:Nat. lambda l:NatList. <cons={n,l}> as NatList;
-
-isnil = lambda l:NatList.
-case l of
-<nil=u> ==> true
-| <cons=p> ==> false;
-
-hd = lambda l:NatList.
-case l of
-<nil=u> ==> 0
-| <cons=p> ==> p.1;
-
-tl = lambda l:NatList.
-case l of
-<nil=u> ==> l
-| <cons=p> ==> p.2;
-
-plus = fix (lambda p:Nat->Nat->Nat.
-lambda m:Nat. lambda n:Nat.
-if iszero m then n else succ (p (pred m) n));
-
-sumlist = fix (lambda s:NatList->Nat. lambda l:NatList.
-if isnil l then 0 else plus (hd l) (s (tl l)));
-
-mylist = cons 2 (cons 3 (cons 5 nil));
-
-sumlist mylist;
-
-
(2/2) Stage this hunk [y,n,q,a,d,K,g,/,e,?]? y

09:10:58 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml +%)
$ git commit -m debug
[ocaml 7fa98a1] debug
 2 files changed, 18 insertions(+), 126 deletions(-)
 rewrite fullequirec/test.f (89%)
09:11:00 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
09:11:01 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
09:11:03 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ git push origin ocaml ^C
09:39:42 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ git push origin ocaml
To github.com:erszcz/tapl-erlang
 ! [rejected]        ocaml -> ocaml (non-fast-forward)
error: failed to push some refs to 'github.com:erszcz/tapl-erlang'
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes (e.g.
hint: 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
09:40:10 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ git l -10
7fa98a1 2022-02-16 debug
8f8e4e6 2022-02-15 fullequirec: Rearrange order for easier diffing with fullsimple
211da04 2022-02-13 fullequirec: Convert to Bytes
780665a 2022-02-13 fullequirec: Rearrange clause order to minimise diffs with fullsimple
b364c24 2021-09-29 Port fullsimple from String to Bytes
7bab897 2021-09-26 Port fulluntyped from String to Bytes
08846af 2021-02-10 Port tyarith from String to Bytes
2d2b274 2021-02-10 Copy test.f over from ../arith
0b560e3 2021-01-04 Add .gitignore
5538362 2021-01-04 Port arith from String to Bytes
09:40:15 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ git fetch origin
09:40:21 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ git rebase origin/ocaml
Successfully rebased and updated refs/heads/ocaml.
09:40:28 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ gitx
09:40:30 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ git push origin ocaml
Enumerating objects: 25, done.
Counting objects: 100% (25/25), done.
Delta compression using up to 8 threads
Compressing objects: 100% (15/15), done.
Writing objects: 100% (15/15), 1.88 KiB | 1.88 MiB/s, done.
Total 15 (delta 13), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (13/13), completed with 8 local objects.
To github.com:erszcz/tapl-erlang
   b3f8d87..2eaffb3  ocaml -> ocaml
09:40:47 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
09:40:48 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ rlwrap ocaml
        OCaml version 4.11.1

#use "main";;
Cannot find file main.
#use "main.cmo";;
File "main.cmo", line 1, characters 12-13:
1 | Caml1999O028
                ^
Error: Illegal character (\000)
#use "main.ml";;
val searchpath : string list ref = {contents = [""]}
val argDefs : (string * Arg.spec * string) list =
  [("-I", Arg.String <fun>, "Append a directory to the search path")]
File "main.ml", line 1:
Error: Reference to undefined global `Support'
#use_rec "main.ml";;
Unknown directive `use_rec'.
# #load_rec "core.cmo";


  ;
  ;;
Error: Syntax error
#load_rec "core.cmo";;
#

#load_rec "main.cmo";;
Error: You must specify an input file


10:07:07 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ rlwrap ocaml
        OCaml version 4.11.1

#load_rec "core.cmo";;
#

1 ;;
- : int = 1
2 ;;
- : int = 2
open Syntax;;
#
open Syntax;;
#
2 ;;
- : int = 2
#

  Interrupted.
# Interrupted.
^D
10:09:06 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ rlwrap ocaml
        OCaml version 4.11.1

#use "main.ml";;
val searchpath : string list ref = {contents = [""]}
val argDefs : (string * Arg.spec * string) list =
  [("-I", Arg.String <fun>, "Append a directory to the search path")]
File "main.ml", line 1:
Error: Reference to undefined global `Support'
#use "core.ml";;
exception NoRuleApplies
val isnumericval : 'a -> Syntax.term -> bool = <fun>
val isval : 'a -> Syntax.term -> bool = <fun>
File "core.ml", line 1:
Error: Reference to undefined global `Syntax'
#use "syntax.ml";;
type ty =
    TyVar of int * int
  | TyId of string
  | TyArr of ty * ty
  | TyUnit
  | TyRecord of (string * ty) list
  | TyRec of string * ty
  | TyVariant of (string * ty) list
  | TyBool
  | TyString
  | TyFloat
  | TyNat
type term =
    TmTrue of Support.Error.info
  | TmFalse of Support.Error.info
  | TmIf of Support.Error.info * term * term * term
  | TmCase of Support.Error.info * term * (string * (string * term)) list
  | TmTag of Support.Error.info * string * term * ty
  | TmVar of Support.Error.info * int * int
  | TmAbs of Support.Error.info * string * ty * term
  | TmApp of Support.Error.info * term * term
  | TmLet of Support.Error.info * string * term * term
  | TmFix of Support.Error.info * term
  | TmString of Support.Error.info * string
  | TmUnit of Support.Error.info
  | TmAscribe of Support.Error.info * term * ty
  | TmRecord of Support.Error.info * (string * term) list
  | TmProj of Support.Error.info * term * string
  | TmFloat of Support.Error.info * float
  | TmTimesfloat of Support.Error.info * term * term
  | TmZero of Support.Error.info
  | TmSucc of Support.Error.info * term
  | TmPred of Support.Error.info * term
  | TmIsZero of Support.Error.info * term
  | TmInert of Support.Error.info * ty
type binding =
    NameBind
  | TyVarBind
  | VarBind of ty
  | TmAbbBind of term * ty option
  | TyAbbBind of ty
type context = (string * binding) list
type command =
    Eval of Support.Error.info * term
  | Bind of Support.Error.info * string * binding
val emptycontext : 'a list = []
val ctxlength : 'a list -> int = <fun>
val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list = <fun>
val addname : ('a * binding) list -> 'a -> ('a * binding) list = <fun>
val isnamebound : ('a * 'b) list -> 'a -> bool = <fun>
val pickfreshname :
  (string * binding) list -> string -> (string * binding) list * string =
  <fun>
File "syntax.ml", line 1:
Error: Reference to undefined global `Support'
#use "support.ml";;
module Error :
  sig
    exception Exit of int
    type info = FI of string * int * int | UNKNOWN
    type 'a withinfo = { i : info; v : 'a; }
    val dummyinfo : info
    val createInfo : string -> int -> int -> info
    val errf : (unit -> 'a) -> 'b
    val printInfo : info -> unit
    val errfAt : info -> (unit -> 'a) -> 'b
    val err : string -> 'a
    val error : info -> string -> 'a
    val warning : string -> unit
    val warningAt : info -> string -> unit
  end
module Pervasive : sig type info = Error.info val pr : string -> unit end
#use "syntax.ml";;
type ty =
    TyVar of int * int
  | TyId of string
  | TyArr of ty * ty
  | TyUnit
  | TyRecord of (string * ty) list
  | TyRec of string * ty
  | TyVariant of (string * ty) list
  | TyBool
  | TyString
  | TyFloat
  | TyNat
type term =
    TmTrue of Support.Error.info
  | TmFalse of Support.Error.info
  | TmIf of Support.Error.info * term * term * term
  | TmCase of Support.Error.info * term * (string * (string * term)) list
  | TmTag of Support.Error.info * string * term * ty
  | TmVar of Support.Error.info * int * int
  | TmAbs of Support.Error.info * string * ty * term
  | TmApp of Support.Error.info * term * term
  | TmLet of Support.Error.info * string * term * term
  | TmFix of Support.Error.info * term
  | TmString of Support.Error.info * string
  | TmUnit of Support.Error.info
  | TmAscribe of Support.Error.info * term * ty
  | TmRecord of Support.Error.info * (string * term) list
  | TmProj of Support.Error.info * term * string
  | TmFloat of Support.Error.info * float
  | TmTimesfloat of Support.Error.info * term * term
  | TmZero of Support.Error.info
  | TmSucc of Support.Error.info * term
  | TmPred of Support.Error.info * term
  | TmIsZero of Support.Error.info * term
  | TmInert of Support.Error.info * ty
type binding =
    NameBind
  | TyVarBind
  | VarBind of ty
  | TmAbbBind of term * ty option
  | TyAbbBind of ty
type context = (string * binding) list
type command =
    Eval of Support.Error.info * term
  | Bind of Support.Error.info * string * binding
val emptycontext : 'a list = []
val ctxlength : 'a list -> int = <fun>
val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list = <fun>
val addname : ('a * binding) list -> 'a -> ('a * binding) list = <fun>
val isnamebound : ('a * 'b) list -> 'a -> bool = <fun>
val pickfreshname :
  (string * binding) list -> string -> (string * binding) list * string =
  <fun>
File "syntax.ml", line 1:
Error: Reference to undefined global `Support'
#use "Support.ml";;
Cannot find file Support.ml.
#use "support.ml";;
module Error :
  sig
    exception Exit of int
    type info = FI of string * int * int | UNKNOWN
    type 'a withinfo = { i : info; v : 'a; }
    val dummyinfo : info
    val createInfo : string -> int -> int -> info
    val errf : (unit -> 'a) -> 'b
    val printInfo : info -> unit
    val errfAt : info -> (unit -> 'a) -> 'b
    val err : string -> 'a
    val error : info -> string -> 'a
    val warning : string -> unit
    val warningAt : info -> string -> unit
  end
module Pervasive : sig type info = Error.info val pr : string -> unit end
#use "syntax.ml";;
type ty =
    TyVar of int * int
  | TyId of string
  | TyArr of ty * ty
  | TyUnit
  | TyRecord of (string * ty) list
  | TyRec of string * ty
  | TyVariant of (string * ty) list
  | TyBool
  | TyString
  | TyFloat
  | TyNat
type term =
    TmTrue of Support.Error.info
  | TmFalse of Support.Error.info
  | TmIf of Support.Error.info * term * term * term
  | TmCase of Support.Error.info * term * (string * (string * term)) list
  | TmTag of Support.Error.info * string * term * ty
  | TmVar of Support.Error.info * int * int
  | TmAbs of Support.Error.info * string * ty * term
  | TmApp of Support.Error.info * term * term
  | TmLet of Support.Error.info * string * term * term
  | TmFix of Support.Error.info * term
  | TmString of Support.Error.info * string
  | TmUnit of Support.Error.info
  | TmAscribe of Support.Error.info * term * ty
  | TmRecord of Support.Error.info * (string * term) list
  | TmProj of Support.Error.info * term * string
  | TmFloat of Support.Error.info * float
  | TmTimesfloat of Support.Error.info * term * term
  | TmZero of Support.Error.info
  | TmSucc of Support.Error.info * term
  | TmPred of Support.Error.info * term
  | TmIsZero of Support.Error.info * term
  | TmInert of Support.Error.info * ty
type binding =
    NameBind
  | TyVarBind
  | VarBind of ty
  | TmAbbBind of term * ty option
  | TyAbbBind of ty
type context = (string * binding) list
type command =
    Eval of Support.Error.info * term
  | Bind of Support.Error.info * string * binding
val emptycontext : 'a list = []
val ctxlength : 'a list -> int = <fun>
val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list = <fun>
val addname : ('a * binding) list -> 'a -> ('a * binding) list = <fun>
val isnamebound : ('a * 'b) list -> 'a -> bool = <fun>
val pickfreshname :
  (string * binding) list -> string -> (string * binding) list * string =
  <fun>
File "syntax.ml", line 1:
Error: Reference to undefined global `Support'
#help ;;
                              General
#help
  Prints a list of all available directives, with corresponding argument type
  if appropriate.
#quit
  Exit the toplevel.

                              Loading code
#cd <str>
  Change the current working directory.
#directory <str>
  Add the given directory to search path for source and compiled files.
#load <str>
  Load in memory a bytecode object, produced by ocamlc.
#load_rec <str>
  As #load, but loads dependencies recursively.
#mod_use <str>
  Usage is identical to #use but #mod_use wraps the contents in a module.
#remove_directory <str>
  Remove the given directory from the search path.
#use <str>
  Read, compile and execute source phrases from the given file.
#use_output <str>
  Execute a command and read, compile and execute source phrases from its
  output.

                              Environment queries
#show <ident>
  Print the signatures of components from any of the categories below.
#show_class <ident>
  Print the signature of the corresponding class.
#show_class_type <ident>
  Print the signature of the corresponding class type.
#show_constructor <ident>
  Print the signature of the corresponding value constructor.
#show_exception <ident>
  Print the signature of the corresponding exception.
#show_module <ident>
  Print the signature of the corresponding module.
#show_module_type <ident>
  Print the signature of the corresponding module type.
#show_type <ident>
  Print the signature of the corresponding type constructor.
#show_val <ident>
  Print the signature of the corresponding value.

                              Pretty-printing
#install_printer <ident>
  Registers a printer for values of a certain type.
#print_depth <int>
  Limit the printing of values to a maximal depth of n.
#print_length <int>
  Limit the number of value nodes printed to at most n.
#remove_printer <ident>
  Remove the named function from the table of toplevel printers.

                              Tracing
#trace <ident>
  All calls to the function named function-name will be traced.
#untrace <ident>
  Stop tracing the given function.
#untrace_all
  Stop tracing all functions traced so far.

                              Compiler options
#labels <bool>
  Choose whether to ignore labels in function types.
#ppx <str>
  After parsing, pipe the abstract syntax tree through the preprocessor
  command.
#principal <bool>
  Make sure that all types are derived in a principal way.
#rectypes
  Allow arbitrary recursive types during type-checking.
#warn_error <str>
  Treat as errors the warnings enabled by the argument.
#warnings <str>
  Enable or disable warnings according to the argument.

#use "syntax.ml";;
type ty =
    TyVar of int * int
  | TyId of string
  | TyArr of ty * ty
  | TyUnit
  | TyRecord of (string * ty) list
  | TyRec of string * ty
  | TyVariant of (string * ty) list
  | TyBool
  | TyString
  | TyFloat
  | TyNat
type term =
    TmTrue of Support.Error.info
  | TmFalse of Support.Error.info
  | TmIf of Support.Error.info * term * term * term
  | TmCase of Support.Error.info * term * (string * (string * term)) list
  | TmTag of Support.Error.info * string * term * ty
  | TmVar of Support.Error.info * int * int
  | TmAbs of Support.Error.info * string * ty * term
  | TmApp of Support.Error.info * term * term
  | TmLet of Support.Error.info * string * term * term
  | TmFix of Support.Error.info * term
  | TmString of Support.Error.info * string
  | TmUnit of Support.Error.info
  | TmAscribe of Support.Error.info * term * ty
  | TmRecord of Support.Error.info * (string * term) list
  | TmProj of Support.Error.info * term * string
  | TmFloat of Support.Error.info * float
  | TmTimesfloat of Support.Error.info * term * term
  | TmZero of Support.Error.info
  | TmSucc of Support.Error.info * term
  | TmPred of Support.Error.info * term
  | TmIsZero of Support.Error.info * term
  | TmInert of Support.Error.info * ty
type binding =
    NameBind
  | TyVarBind
  | VarBind of ty
  | TmAbbBind of term * ty option
  | TyAbbBind of ty
type context = (string * binding) list
type command =
    Eval of Support.Error.info * term
  | Bind of Support.Error.info * string * binding
val emptycontext : 'a list = []
val ctxlength : 'a list -> int = <fun>
val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list = <fun>
val addname : ('a * binding) list -> 'a -> ('a * binding) list = <fun>
val isnamebound : ('a * 'b) list -> 'a -> bool = <fun>
val pickfreshname :
  (string * binding) list -> string -> (string * binding) list * string =
  <fun>
File "syntax.ml", line 1:
Error: Reference to undefined global `Support'
#use "support.ml";;
module Error :
  sig
    exception Exit of int
    type info = FI of string * int * int | UNKNOWN
    type 'a withinfo = { i : info; v : 'a; }
    val dummyinfo : info
    val createInfo : string -> int -> int -> info
    val errf : (unit -> 'a) -> 'b
    val printInfo : info -> unit
    val errfAt : info -> (unit -> 'a) -> 'b
    val err : string -> 'a
    val error : info -> string -> 'a
    val warning : string -> unit
    val warningAt : info -> string -> unit
  end
module Pervasive : sig type info = Error.info val pr : string -> unit end
#use "support.ml";;
module Error :
  sig
    exception Exit of int
    type info = FI of string * int * int | UNKNOWN
    type 'a withinfo = { i : info; v : 'a; }
    val dummyinfo : info
    val createInfo : string -> int -> int -> info
    val errf : (unit -> 'a) -> 'b
    val printInfo : info -> unit
    val errfAt : info -> (unit -> 'a) -> 'b
    val err : string -> 'a
    val error : info -> string -> 'a
    val warning : string -> unit
    val warningAt : info -> string -> unit
  end
module Pervasive : sig type info = Error.info val pr : string -> unit end
#use "syntax.ml";;
type ty =
    TyVar of int * int
  | TyId of string
  | TyArr of ty * ty
  | TyUnit
  | TyRecord of (string * ty) list
  | TyRec of string * ty
  | TyVariant of (string * ty) list
  | TyBool
  | TyString
  | TyFloat
  | TyNat
type term =
    TmTrue of Support.Error.info
  | TmFalse of Support.Error.info
  | TmIf of Support.Error.info * term * term * term
  | TmCase of Support.Error.info * term * (string * (string * term)) list
  | TmTag of Support.Error.info * string * term * ty
  | TmVar of Support.Error.info * int * int
  | TmAbs of Support.Error.info * string * ty * term
  | TmApp of Support.Error.info * term * term
  | TmLet of Support.Error.info * string * term * term
  | TmFix of Support.Error.info * term
  | TmString of Support.Error.info * string
  | TmUnit of Support.Error.info
  | TmAscribe of Support.Error.info * term * ty
  | TmRecord of Support.Error.info * (string * term) list
  | TmProj of Support.Error.info * term * string
  | TmFloat of Support.Error.info * float
  | TmTimesfloat of Support.Error.info * term * term
  | TmZero of Support.Error.info
  | TmSucc of Support.Error.info * term
  | TmPred of Support.Error.info * term
  | TmIsZero of Support.Error.info * term
  | TmInert of Support.Error.info * ty
type binding =
    NameBind
  | TyVarBind
  | VarBind of ty
  | TmAbbBind of term * ty option
  | TyAbbBind of ty
type context = (string * binding) list
type command =
    Eval of Support.Error.info * term
  | Bind of Support.Error.info * string * binding
val emptycontext : 'a list = []
val ctxlength : 'a list -> int = <fun>
val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list = <fun>
val addname : ('a * binding) list -> 'a -> ('a * binding) list = <fun>
val isnamebound : ('a * 'b) list -> 'a -> bool = <fun>
val pickfreshname :
  (string * binding) list -> string -> (string * binding) list * string =
  <fun>
File "syntax.ml", line 1:
Error: Reference to undefined global `Support'
# #use "topfind";
  ;
  #use "topfind";;
Error: Syntax error
#use "topfind";;
- : unit = ()
Findlib has been successfully loaded. Additional directives:
  #require "package";;      to load a package
  #list;;                   to list the available packages
  #camlp4o;;                to load camlp4 (standard syntax)
  #camlp4r;;                to load camlp4 (revised syntax)
  #predicates "p,q,...";;   to set these predicates
  Topfind.reset();;         to force that packages will be reloaded
  #thread;;                 to enable threads

- : unit = ()
#require "support";;
No such package: support
#require "support.ml";;
No such package: support.ml
#

^D
10:12:40 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$
10:12:41 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ rlwrap ocaml
        OCaml version 4.11.1

#mod_use "support.ml";;
module Support :
  sig
    module Error :
      sig
        exception Exit of int
        type info = FI of string * int * int | UNKNOWN
        type 'a withinfo = { i : info; v : 'a; }
        val dummyinfo : info
        val createInfo : string -> int -> int -> info
        val errf : (unit -> 'a) -> 'b
        val printInfo : info -> unit
        val errfAt : info -> (unit -> 'a) -> 'b
        val err : string -> 'a
        val error : info -> string -> 'a
        val warning : string -> unit
        val warningAt : info -> string -> unit
      end
    module Pervasive : sig type info = Error.info val pr : string -> unit end
  end
#mod_use "syntax.ml";;
module Syntax :
  sig
    type ty =
        TyVar of int * int
      | TyId of string
      | TyArr of ty * ty
      | TyUnit
      | TyRecord of (string * ty) list
      | TyRec of string * ty
      | TyVariant of (string * ty) list
      | TyBool
      | TyString
      | TyFloat
      | TyNat
    type term =
        TmTrue of Support.Pervasive.info
      | TmFalse of Support.Pervasive.info
      | TmIf of Support.Pervasive.info * term * term * term
      | TmCase of Support.Pervasive.info * term *
          (string * (string * term)) list
      | TmTag of Support.Pervasive.info * string * term * ty
      | TmVar of Support.Pervasive.info * int * int
      | TmAbs of Support.Pervasive.info * string * ty * term
      | TmApp of Support.Pervasive.info * term * term
      | TmLet of Support.Pervasive.info * string * term * term
      | TmFix of Support.Pervasive.info * term
      | TmString of Support.Pervasive.info * string
      | TmUnit of Support.Pervasive.info
      | TmAscribe of Support.Pervasive.info * term * ty
      | TmRecord of Support.Pervasive.info * (string * term) list
      | TmProj of Support.Pervasive.info * term * string
      | TmFloat of Support.Pervasive.info * float
      | TmTimesfloat of Support.Pervasive.info * term * term
      | TmZero of Support.Pervasive.info
      | TmSucc of Support.Pervasive.info * term
      | TmPred of Support.Pervasive.info * term
      | TmIsZero of Support.Pervasive.info * term
      | TmInert of Support.Pervasive.info * ty
    type binding =
        NameBind
      | TyVarBind
      | VarBind of ty
      | TmAbbBind of term * ty option
      | TyAbbBind of ty
    type context = (string * binding) list
    type command =
        Eval of Support.Pervasive.info * term
      | Bind of Support.Pervasive.info * string * binding
    val emptycontext : 'a list
    val ctxlength : 'a list -> int
    val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list
    val addname : ('a * binding) list -> 'a -> ('a * binding) list
    val isnamebound : ('a * 'b) list -> 'a -> bool
    val pickfreshname :
      (string * binding) list -> string -> (string * binding) list * string
    val index2name : Support.Error.info -> ('a * 'b) list -> int -> 'a
    val name2index :
      Support.Error.info -> (string * 'a) list -> string -> int
    val tymap : (int -> int -> int -> ty) -> int -> ty -> ty
    val tmmap :
      (Support.Pervasive.info -> int -> int -> int -> term) ->
      (int -> ty -> ty) -> int -> term -> term
    val typeShiftAbove : int -> int -> ty -> ty
    val termShiftAbove : int -> int -> term -> term
    val termShift : int -> term -> term
    val typeShift : int -> ty -> ty
    val bindingshift : int -> binding -> binding
    val termSubst : int -> term -> term -> term
    val termSubstTop : term -> term -> term
    val typeSubst : ty -> int -> ty -> ty
    val typeSubstTop : ty -> ty -> ty
    val tytermSubst : ty -> int -> term -> term
    val tytermSubstTop : ty -> term -> term
    val getbinding :
      Support.Error.info -> ('a * binding) list -> int -> binding
    val getTypeFromContext :
      Support.Error.info -> (string * binding) list -> int -> ty
    val tmInfo : term -> Support.Pervasive.info
    val obox0 : unit -> unit
    val obox : unit -> unit
    val cbox : unit -> unit
    val break : unit -> unit
    val small : term -> bool
    val printty_Type : bool -> (string * binding) list -> ty -> unit
    val printty_ArrowType : bool -> (string * binding) list -> ty -> unit
    val printty_AType : bool -> (string * binding) list -> ty -> unit
    val printty : (string * binding) list -> ty -> unit
    val printtm_Term : bool -> (string * binding) list -> term -> unit
    val printtm_AppTerm : bool -> (string * binding) list -> term -> unit
    val printtm_AscribeTerm : bool -> (string * binding) list -> term -> unit
    val printtm_PathTerm : bool -> (string * binding) list -> term -> unit
    val printtm_ATerm : bool -> (string * binding) list -> term -> unit
    val printtm : (string * binding) list -> term -> unit
    val prbinding : (string * binding) list -> binding -> unit
  end
#mod_use "lexer.ml";;
File "lexer.mll", line 85, characters 59-72:
Error: This expression has type
         (string * (Support/2.Error.info -> Parser.token)) list
       but an expression was expected of type (string * buildfun) list
       Type Support/2.Error.info -> Parser.token is not compatible with type
         buildfun = Support/1.Error.info -> Parser.token
       Type Support/2.Error.info is not compatible with type
         Support/1.Error.info
       File "_none_", line 1:
         Definition of module Support/1
       File "_none_", line 1:
         Definition of module Support/2
#mod_use "core.ml";;
module Core :
  sig
    exception NoRuleApplies
    val isnumericval : 'a -> Syntax.term -> bool
    val isval : 'a -> Syntax.term -> bool
    val eval1 : ('a * Syntax.binding) list -> Syntax.term -> Syntax.term
    val eval : ('a * Syntax.binding) list -> Syntax.term -> Syntax.term
    val evalbinding :
      ('a * Syntax.binding) list -> Syntax.binding -> Syntax.binding
    val istyabb : ('a * Syntax.binding) list -> int -> bool
    val gettyabb : ('a * Syntax.binding) list -> int -> Syntax.ty
    val computety : ('a * Syntax.binding) list -> Syntax.ty -> Syntax.ty
    val simplifyty : ('a * Syntax.binding) list -> Syntax.ty -> Syntax.ty
    val tyeqv :
      (string * Syntax.binding) list -> Syntax.ty -> Syntax.ty -> bool
    val typeof : (string * Syntax.binding) list -> Syntax.term -> Syntax.ty
  end
#mod_use "main.ml";;
File "main.ml", line 47, characters 10-29:
47 |     error (Lexer.info lexbuf) "Parse error"
               ^^^^^^^^^^^^^^^^^^^
Error: This expression has type Support/2.Error.info
       but an expression was expected of type Support/1.Error.info
       File "_none_", line 1:
         Definition of module Support/1
       File "_none_", line 1:
         Definition of module Support/2
#mod_use "parser.ml";;
module Parser :
  sig
    type token =
        TYPE of Support.Error.info
      | INERT of Support.Error.info
      | IF of Support.Error.info
      | THEN of Support.Error.info
      | ELSE of Support.Error.info
      | TRUE of Support.Error.info
      | FALSE of Support.Error.info
      | BOOL of Support.Error.info
      | CASE of Support.Error.info
      | OF of Support.Error.info
      | AS of Support.Error.info
      | LAMBDA of Support.Error.info
      | LET of Support.Error.info
      | IN of Support.Error.info
      | FIX of Support.Error.info
      | LETREC of Support.Error.info
      | USTRING of Support.Error.info
      | UNIT of Support.Error.info
      | UUNIT of Support.Error.info
      | TIMESFLOAT of Support.Error.info
      | UFLOAT of Support.Error.info
      | REC of Support.Error.info
      | SUCC of Support.Error.info
      | PRED of Support.Error.info
      | ISZERO of Support.Error.info
      | NAT of Support.Error.info
      | UCID of string Support.Error.withinfo
      | LCID of string Support.Error.withinfo
      | INTV of int Support.Error.withinfo
      | FLOATV of float Support.Error.withinfo
      | STRINGV of string Support.Error.withinfo
      | APOSTROPHE of Support.Error.info
      | DQUOTE of Support.Error.info
      | ARROW of Support.Error.info
      | BANG of Support.Error.info
      | BARGT of Support.Error.info
      | BARRCURLY of Support.Error.info
      | BARRSQUARE of Support.Error.info
      | COLON of Support.Error.info
      | COLONCOLON of Support.Error.info
      | COLONEQ of Support.Error.info
      | COLONHASH of Support.Error.info
      | COMMA of Support.Error.info
      | DARROW of Support.Error.info
      | DDARROW of Support.Error.info
      | DOT of Support.Error.info
      | EOF of Support.Error.info
      | EQ of Support.Error.info
      | EQEQ of Support.Error.info
      | EXISTS of Support.Error.info
      | GT of Support.Error.info
      | HASH of Support.Error.info
      | LCURLY of Support.Error.info
      | LCURLYBAR of Support.Error.info
      | LEFTARROW of Support.Error.info
      | LPAREN of Support.Error.info
      | LSQUARE of Support.Error.info
      | LSQUAREBAR of Support.Error.info
      | LT of Support.Error.info
      | RCURLY of Support.Error.info
      | RPAREN of Support.Error.info
      | RSQUARE of Support.Error.info
      | SEMI of Support.Error.info
      | SLASH of Support.Error.info
      | STAR of Support.Error.info
      | TRIANGLE of Support.Error.info
      | USCORE of Support.Error.info
      | VBAR of Support.Error.info
    val yytransl_const : int array
    val yytransl_block : int array
    val yylhs : string
    val yylen : string
    val yydefred : string
    val yydgoto : string
    val yysindex : string
    val yyrindex : string
    val yygindex : string
    val yytablesize : int
    val yytable : string
    val yycheck : string
    val yynames_const : string
    val yynames_block : string
    val yyact : (Parsing.parser_env -> Obj.t) array
    val yytables : Parsing.parse_tables
    val toplevel :
      (Lexing.lexbuf -> token) ->
      Lexing.lexbuf -> Syntax.context -> Syntax.command list * Syntax.context
  end
#mod_use "lexer.ml";;
module Lexer :
  sig
    val reservedWords : (string * (Support.Error.info -> Parser.token)) list
    type buildfun = Support.Error.info -> Parser.token
    val symbolTable : (string, buildfun) Hashtbl.t
    val createID : Support.Error.info -> string -> Parser.token
    val lineno : int ref
    val depth : int ref
    val start : int ref
    val filename : string ref
    val startLex : Support.Error.info ref
    val create : string -> in_channel -> Lexing.lexbuf
    val newline : Lexing.lexbuf -> unit
    val info : Lexing.lexbuf -> Support.Error.info
    val text : Lexing.lexbuf -> string
    val stringBuffer : bytes ref
    val stringEnd : int ref
    val resetStr : unit -> unit
    val addStr : char -> unit
    val getStr : unit -> string
    val extractLineno : string -> int -> int
    val __ocaml_lex_tables : Lexing.lex_tables
    val main : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_main_rec : Lexing.lexbuf -> int -> Parser.token
    val comment : Lexing.lexbuf -> unit
    val __ocaml_lex_comment_rec : Lexing.lexbuf -> int -> unit
    val getFile : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_getFile_rec : Lexing.lexbuf -> int -> Parser.token
    val getName : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_getName_rec : Lexing.lexbuf -> int -> Parser.token
    val finishName : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_finishName_rec : Lexing.lexbuf -> int -> Parser.token
    val string : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_string_rec : Lexing.lexbuf -> int -> Parser.token
    val escaped : Lexing.lexbuf -> char
    val __ocaml_lex_escaped_rec : Lexing.lexbuf -> int -> char
  end
#mod_use "core.ml";;
module Core :
  sig
    exception NoRuleApplies
    val isnumericval : 'a -> Syntax.term -> bool
    val isval : 'a -> Syntax.term -> bool
    val eval1 : ('a * Syntax.binding) list -> Syntax.term -> Syntax.term
    val eval : ('a * Syntax.binding) list -> Syntax.term -> Syntax.term
    val evalbinding :
      ('a * Syntax.binding) list -> Syntax.binding -> Syntax.binding
    val istyabb : ('a * Syntax.binding) list -> int -> bool
    val gettyabb : ('a * Syntax.binding) list -> int -> Syntax.ty
    val computety : ('a * Syntax.binding) list -> Syntax.ty -> Syntax.ty
    val simplifyty : ('a * Syntax.binding) list -> Syntax.ty -> Syntax.ty
    val tyeqv :
      (string * Syntax.binding) list -> Syntax.ty -> Syntax.ty -> bool
    val typeof : (string * Syntax.binding) list -> Syntax.term -> Syntax.ty
  end
#mod_use "main.ml";;
Error: You must specify an input file


10:15:34 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml %)
$ rlwrap ocaml
        OCaml version 4.11.1

#mod_use "main.ml";;
File "main.ml", line 110, characters 8-12:
110 |     try main();0
              ^^^^
Error: Unbound value main
Hint: Did you mean min?
#use "main.ml";;
val searchpath : string list ref = {contents = [""]}
val argDefs : (string * Arg.spec * string) list =
  [("-I", Arg.String <fun>, "Append a directory to the search path")]
File "main.ml", line 1:
Error: Reference to undefined global `Support'
#mod_use "support.ml";;
module Support :
  sig
    module Error :
      sig
        exception Exit of int
        type info = FI of string * int * int | UNKNOWN
        type 'a withinfo = { i : info; v : 'a; }
        val dummyinfo : info
        val createInfo : string -> int -> int -> info
        val errf : (unit -> 'a) -> 'b
        val printInfo : info -> unit
        val errfAt : info -> (unit -> 'a) -> 'b
        val err : string -> 'a
        val error : info -> string -> 'a
        val warning : string -> unit
        val warningAt : info -> string -> unit
      end
    module Pervasive : sig type info = Error.info val pr : string -> unit end
  end
#mod_use "syntax.ml";;
module Syntax :
  sig
    type ty =
        TyVar of int * int
      | TyId of string
      | TyArr of ty * ty
      | TyUnit
      | TyRecord of (string * ty) list
      | TyRec of string * ty
      | TyVariant of (string * ty) list
      | TyBool
      | TyString
      | TyFloat
      | TyNat
    type term =
        TmTrue of Support.Pervasive.info
      | TmFalse of Support.Pervasive.info
      | TmIf of Support.Pervasive.info * term * term * term
      | TmCase of Support.Pervasive.info * term *
          (string * (string * term)) list
      | TmTag of Support.Pervasive.info * string * term * ty
      | TmVar of Support.Pervasive.info * int * int
      | TmAbs of Support.Pervasive.info * string * ty * term
      | TmApp of Support.Pervasive.info * term * term
      | TmLet of Support.Pervasive.info * string * term * term
      | TmFix of Support.Pervasive.info * term
      | TmString of Support.Pervasive.info * string
      | TmUnit of Support.Pervasive.info
      | TmAscribe of Support.Pervasive.info * term * ty
      | TmRecord of Support.Pervasive.info * (string * term) list
      | TmProj of Support.Pervasive.info * term * string
      | TmFloat of Support.Pervasive.info * float
      | TmTimesfloat of Support.Pervasive.info * term * term
      | TmZero of Support.Pervasive.info
      | TmSucc of Support.Pervasive.info * term
      | TmPred of Support.Pervasive.info * term
      | TmIsZero of Support.Pervasive.info * term
      | TmInert of Support.Pervasive.info * ty
    type binding =
        NameBind
      | TyVarBind
      | VarBind of ty
      | TmAbbBind of term * ty option
      | TyAbbBind of ty
    type context = (string * binding) list
    type command =
        Eval of Support.Pervasive.info * term
      | Bind of Support.Pervasive.info * string * binding
    val emptycontext : 'a list
    val ctxlength : 'a list -> int
    val addbinding : ('a * 'b) list -> 'a -> 'b -> ('a * 'b) list
    val addname : ('a * binding) list -> 'a -> ('a * binding) list
    val isnamebound : ('a * 'b) list -> 'a -> bool
    val pickfreshname :
      (string * binding) list -> string -> (string * binding) list * string
    val index2name : Support.Error.info -> ('a * 'b) list -> int -> 'a
    val name2index :
      Support.Error.info -> (string * 'a) list -> string -> int
    val tymap : (int -> int -> int -> ty) -> int -> ty -> ty
    val tmmap :
      (Support.Pervasive.info -> int -> int -> int -> term) ->
      (int -> ty -> ty) -> int -> term -> term
    val typeShiftAbove : int -> int -> ty -> ty
    val termShiftAbove : int -> int -> term -> term
    val termShift : int -> term -> term
    val typeShift : int -> ty -> ty
    val bindingshift : int -> binding -> binding
    val termSubst : int -> term -> term -> term
    val termSubstTop : term -> term -> term
    val typeSubst : ty -> int -> ty -> ty
    val typeSubstTop : ty -> ty -> ty
    val tytermSubst : ty -> int -> term -> term
    val tytermSubstTop : ty -> term -> term
    val getbinding :
      Support.Error.info -> ('a * binding) list -> int -> binding
    val getTypeFromContext :
      Support.Error.info -> (string * binding) list -> int -> ty
    val tmInfo : term -> Support.Pervasive.info
    val obox0 : unit -> unit
    val obox : unit -> unit
    val cbox : unit -> unit
    val break : unit -> unit
    val small : term -> bool
    val printty_Type : bool -> (string * binding) list -> ty -> unit
    val printty_ArrowType : bool -> (string * binding) list -> ty -> unit
    val printty_AType : bool -> (string * binding) list -> ty -> unit
    val printty : (string * binding) list -> ty -> unit
    val printtm_Term : bool -> (string * binding) list -> term -> unit
    val printtm_AppTerm : bool -> (string * binding) list -> term -> unit
    val printtm_AscribeTerm : bool -> (string * binding) list -> term -> unit
    val printtm_PathTerm : bool -> (string * binding) list -> term -> unit
    val printtm_ATerm : bool -> (string * binding) list -> term -> unit
    val printtm : (string * binding) list -> term -> unit
    val prbinding : (string * binding) list -> binding -> unit
  end
#mod_use "parser.ml";;
module Parser :
  sig
    type token =
        TYPE of Support.Error.info
      | INERT of Support.Error.info
      | IF of Support.Error.info
      | THEN of Support.Error.info
      | ELSE of Support.Error.info
      | TRUE of Support.Error.info
      | FALSE of Support.Error.info
      | BOOL of Support.Error.info
      | CASE of Support.Error.info
      | OF of Support.Error.info
      | AS of Support.Error.info
      | LAMBDA of Support.Error.info
      | LET of Support.Error.info
      | IN of Support.Error.info
      | FIX of Support.Error.info
      | LETREC of Support.Error.info
      | USTRING of Support.Error.info
      | UNIT of Support.Error.info
      | UUNIT of Support.Error.info
      | TIMESFLOAT of Support.Error.info
      | UFLOAT of Support.Error.info
      | REC of Support.Error.info
      | SUCC of Support.Error.info
      | PRED of Support.Error.info
      | ISZERO of Support.Error.info
      | NAT of Support.Error.info
      | UCID of string Support.Error.withinfo
      | LCID of string Support.Error.withinfo
      | INTV of int Support.Error.withinfo
      | FLOATV of float Support.Error.withinfo
      | STRINGV of string Support.Error.withinfo
      | APOSTROPHE of Support.Error.info
      | DQUOTE of Support.Error.info
      | ARROW of Support.Error.info
      | BANG of Support.Error.info
      | BARGT of Support.Error.info
      | BARRCURLY of Support.Error.info
      | BARRSQUARE of Support.Error.info
      | COLON of Support.Error.info
      | COLONCOLON of Support.Error.info
      | COLONEQ of Support.Error.info
      | COLONHASH of Support.Error.info
      | COMMA of Support.Error.info
      | DARROW of Support.Error.info
      | DDARROW of Support.Error.info
      | DOT of Support.Error.info
      | EOF of Support.Error.info
      | EQ of Support.Error.info
      | EQEQ of Support.Error.info
      | EXISTS of Support.Error.info
      | GT of Support.Error.info
      | HASH of Support.Error.info
      | LCURLY of Support.Error.info
      | LCURLYBAR of Support.Error.info
      | LEFTARROW of Support.Error.info
      | LPAREN of Support.Error.info
      | LSQUARE of Support.Error.info
      | LSQUAREBAR of Support.Error.info
      | LT of Support.Error.info
      | RCURLY of Support.Error.info
      | RPAREN of Support.Error.info
      | RSQUARE of Support.Error.info
      | SEMI of Support.Error.info
      | SLASH of Support.Error.info
      | STAR of Support.Error.info
      | TRIANGLE of Support.Error.info
      | USCORE of Support.Error.info
      | VBAR of Support.Error.info
    val yytransl_const : int array
    val yytransl_block : int array
    val yylhs : string
    val yylen : string
    val yydefred : string
    val yydgoto : string
    val yysindex : string
    val yyrindex : string
    val yygindex : string
    val yytablesize : int
    val yytable : string
    val yycheck : string
    val yynames_const : string
    val yynames_block : string
    val yyact : (Parsing.parser_env -> Obj.t) array
    val yytables : Parsing.parse_tables
    val toplevel :
      (Lexing.lexbuf -> token) ->
      Lexing.lexbuf -> Syntax.context -> Syntax.command list * Syntax.context
  end
#mod_use "lexer.ml";;
module Lexer :
  sig
    val reservedWords : (string * (Support.Error.info -> Parser.token)) list
    type buildfun = Support.Error.info -> Parser.token
    val symbolTable : (string, buildfun) Hashtbl.t
    val createID : Support.Error.info -> string -> Parser.token
    val lineno : int ref
    val depth : int ref
    val start : int ref
    val filename : string ref
    val startLex : Support.Error.info ref
    val create : string -> in_channel -> Lexing.lexbuf
    val newline : Lexing.lexbuf -> unit
    val info : Lexing.lexbuf -> Support.Error.info
    val text : Lexing.lexbuf -> string
    val stringBuffer : bytes ref
    val stringEnd : int ref
    val resetStr : unit -> unit
    val addStr : char -> unit
    val getStr : unit -> string
    val extractLineno : string -> int -> int
    val __ocaml_lex_tables : Lexing.lex_tables
    val main : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_main_rec : Lexing.lexbuf -> int -> Parser.token
    val comment : Lexing.lexbuf -> unit
    val __ocaml_lex_comment_rec : Lexing.lexbuf -> int -> unit
    val getFile : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_getFile_rec : Lexing.lexbuf -> int -> Parser.token
    val getName : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_getName_rec : Lexing.lexbuf -> int -> Parser.token
    val finishName : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_finishName_rec : Lexing.lexbuf -> int -> Parser.token
    val string : Lexing.lexbuf -> Parser.token
    val __ocaml_lex_string_rec : Lexing.lexbuf -> int -> Parser.token
    val escaped : Lexing.lexbuf -> char
    val __ocaml_lex_escaped_rec : Lexing.lexbuf -> int -> char
  end
#mod_use "core.ml";;
module Core :
  sig
    exception NoRuleApplies
    val isnumericval : 'a -> Syntax.term -> bool
    val isval : 'a -> Syntax.term -> bool
    val eval1 : ('a * Syntax.binding) list -> Syntax.term -> Syntax.term
    val eval : ('a * Syntax.binding) list -> Syntax.term -> Syntax.term
    val evalbinding :
      ('a * Syntax.binding) list -> Syntax.binding -> Syntax.binding
    val istyabb : ('a * Syntax.binding) list -> int -> bool
    val gettyabb : ('a * Syntax.binding) list -> int -> Syntax.ty
    val computety : ('a * Syntax.binding) list -> Syntax.ty -> Syntax.ty
    val simplifyty : ('a * Syntax.binding) list -> Syntax.ty -> Syntax.ty
    val tyeqv :
      (string * Syntax.binding) list -> Syntax.ty -> Syntax.ty -> bool
    val typeof : (string * Syntax.binding) list -> Syntax.term -> Syntax.ty
  end
#mod_use "main.ml";;
File "main.ml", line 110, characters 8-12:
110 |     try main();0
              ^^^^
Error: Unbound value main
Hint: Did you mean min?
#mod_use "main.ml";;
Error: You must specify an input file


module Main :
  sig
    val searchpath : string list ref
    val argDefs : (string * Arg.spec * string) list
    val parseArgs : unit -> string
    val openfile : string -> in_channel
    val parseFile :
      string ->
      Syntax.context -> Syntax.command list * Syntax.context
    val alreadyImported : string list ref
    val checkbinding :
      Support.Error.info ->
      (string * Syntax.binding) list ->
      Syntax.binding -> Syntax.binding
    val prbindingty :
      (string * Syntax.binding) list -> Syntax.binding -> unit
    val process_command :
      (string * Syntax.binding) list ->
      Syntax.command -> (string * Syntax.binding) list
    val process_file : string -> Syntax.context -> Syntax.context
    val main : unit -> unit
    val res : int
  end
# Main.emptycontext ;;
Error: Unbound value Main.emptycontext
# emptycontext ;;
Error: Reference to undefined global `Syntax'
Syntax.emptycontext ;;
- : 'a list = []
Main.process_file "test.f" Syntax.emptycontext ;;
Counter :: *






NatNattrue{x:Nat}{x:Nat}true{x:Nat} ->
                            {
get:Nat, inc:Unit->Counter}{x:Nat} ->
                                                        Counter
true
{
x:Nat}
{
x:Nat}true
p : {get:Nat, inc:Unit->Counter}
- : Syntax.context =
[("p",
  Syntax.TmAbbBind
   (Syntax.TmRecord
     (Support.Error.FI
       ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
       8, 9),
     [("get",
       Syntax.TmZero
        (Support.Error.FI
          ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
          11, 13)));
      ("inc",
       Syntax.TmAbs
        (Support.Error.FI
          ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
          9, 16),
        "_", Syntax.TyUnit,
        Syntax.TmApp
         (Support.Error.FI
           ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
           9, 31),
         Syntax.TmFix
          (Support.Error.FI
            ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
            5, 4),
          Syntax.TmAbs
           (Support.Error.FI
             ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
             6, 7),
           "cr",
           Syntax.TyArr (Syntax.TyRecord [("x", Syntax.TyNat)],
            Syntax.TyVar (1, 2)),
           Syntax.TmAbs
            (Support.Error.FI
              ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
              7, 7),
            "s", Syntax.TyRecord [("x", Syntax.TyNat)],
            Syntax.TmRecord
             (Support.Error.FI
               ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
               8, 9),
             [("get",
               Syntax.TmProj
                (Support.Error.FI
                  ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                  8, 17),
                Syntax.TmVar
                 (Support.Error.FI
                   ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                   8, 16),
                 0, 4),
                "x"));
              ("inc",
               Syntax.TmAbs
                (Support.Error.FI
                  ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                  9, 16),
                "_", Syntax.TyUnit,
                Syntax.TmApp
                 (Support.Error.FI
                   ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                   9, 31),
                 Syntax.TmVar
                  (Support.Error.FI
                    ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                    9, 31),
                  2, 5),
                 Syntax.TmRecord
                  (Support.Error.FI
                    ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                    9, 34),
                  [("x",
                    Syntax.TmSucc
                     (Support.Error.FI
                       ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                       9, 37),
                     Syntax.TmProj
                      (Support.Error.FI
                        ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                        9, 43),
                      Syntax.TmVar
                       (Support.Error.FI
                         ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                         9, 42),
                       1, 5),
                      "x")))]))))])))),
         Syntax.TmRecord
          (Support.Error.FI
            ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
            9, 34),
          [("x",
            Syntax.TmSucc
             (Support.Error.FI
               ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
               9, 37),
             Syntax.TmProj
              (Support.Error.FI
                ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                9, 43),
              Syntax.TmRecord
               (Support.Error.FI
                 ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                 11, 10),
               [("x",
                 Syntax.TmZero
                  (Support.Error.FI
                    ("/Users/erszcz/work/erszcz/tapl-ocaml/fullequirec/test.f",
                    11, 13)))]),
              "x")))]))))]),
   Some
    (Syntax.TyRecord
      [("get", Syntax.TyNat);
       ("inc", Syntax.TyArr (Syntax.TyUnit, Syntax.TyVar (0, 1)))])));
 ("Counter",
  Syntax.TyAbbBind
   (Syntax.TyRec ("P",
     Syntax.TyRecord
      [("get", Syntax.TyNat);
       ("inc", Syntax.TyArr (Syntax.TyUnit, Syntax.TyVar (0, 1)))])))]
#
Interrupted.
^D
10:18:46 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ rlwrap
.depend        core.cmi       core.ml        f              lexer.cmo      lexer.mll      main.cmo       parser.cmi     parser.ml      parser.mly     support.cmi    support.ml     syntax.cmi     syntax.ml      test.f
Makefile       core.cmo       core.mli       lexer.cmi      lexer.ml       main.cmi       main.ml        parser.cmo     parser.mli     parser.output  support.cmo    support.mli    syntax.cmo     syntax.mli
10:18:46 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ rlwrap ^C
10:18:52 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$ ls ~/*.hist*
ls: /Users/erszcz/*.hist*: No such file or directory
10:19:01 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$
10:19:03 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$
10:19:04 erszcz @ x6 : ~/work/erszcz/tapl-ocaml/fullequirec (ocaml *%)
$