As I added ports for the different implementations, I realized that I was duplicating a lot of code. I abstracted some into common files, but when one of the main types would change slightly (e.g., a new type was added), I didn't know how to cleanly abstract across the different versions of the type. I considered Template Haskell, but I did not want to sacrifice readability of individual implementations.

I eventually settled on using code generation. In a config file (suffixed with "gen"), an implementation specifies sets of terms, types, tests, and other global options, and all of the necessary code is then generated in its 'gen' subdirectory. The generator itself is not pretty, but this approach allows the user to explore an individual implementation without suffering (too much) from abstractions that are not relevant to the code at hand. (Of course, any changes will be lost unless they are migrated to the generator.)
